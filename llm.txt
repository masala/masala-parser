You are an AI assistant helping developers use **Masala Parser v2**.

- Language: JavaScript and TypeScript.
- Core concepts: parser combinators, Parsec-like API, streams.
- Always prefer real APIs and examples from this file.
- If something is unclear or not documented, say it explicitly.

Below is a curated snapshot of the docs, tests and examples, generated with git-ingest tool.

Each section starts with :
"
================================================
FILE: <path>
================================================
"



Directory structure:
└── masala-masala-parser/
    └── ingest/
        ├── README.md
        ├── documentation/
        │   ├── chain.md
        │   ├── chars-bundle.md
        │   ├── flow-bundle.md
        │   ├── genlex.md
        │   ├── numbers-bundle.md
        │   ├── parser-core-functions.md
        │   ├── parser-extension-functions.md
        │   ├── publish.md
        │   ├── recursion.md
        │   ├── troubleshooting.md
        │   └── tuple.md
        ├── examples/
        │   ├── index.ts
        │   ├── 1-easy/
        │   │   ├── chars.spec.ts
        │   │   ├── floor.spec.ts
        │   │   ├── hello-something.spec.ts
        │   │   ├── number.spec.ts
        │   │   ├── occurence.spec.ts
        │   │   └── response.spec.ts
        │   ├── 2-medium/
        │   │   ├── f-layer.spec.ts
        │   │   ├── filter-match.spec.ts
        │   │   ├── flat-map.spec.ts
        │   │   └── real-world-flatmap.spec.ts
        │   ├── brainfuck/
        │   │   └── compiler.spec.ts
        │   ├── chars/
        │   │   ├── charIn-notChar.spec.ts
        │   │   └── letter-letterAs.spec.ts
        │   ├── flow/
        │   │   ├── nop-any-eos.spec.ts
        │   │   ├── not.spec.ts
        │   │   ├── startWith-moveUntil-dropTo.spec.ts
        │   │   └── try-with-no-or.spec.ts
        │   ├── lazy/
        │   │   └── transmission.spec.ts
        │   ├── markdown/
        │   │   ├── lib/
        │   │   │   ├── bullet-parser.ts
        │   │   │   ├── code-line-parser.ts
        │   │   │   ├── document-parser.ts
        │   │   │   ├── front-matter.ts
        │   │   │   ├── text-parser.ts
        │   │   │   ├── title-parser.ts
        │   │   │   ├── token.ts
        │   │   │   └── types.ts
        │   │   └── test/
        │   │       ├── bullet-test.ts
        │   │       ├── code-block-test.ts
        │   │       ├── document-test.ts
        │   │       ├── front-matter.spec.ts
        │   │       ├── markdown-test.ts
        │   │       ├── text-test.ts
        │   │       ├── title-test.ts
        │   │       └── samples/
        │   │           ├── paragraph-expected.json
        │   │           ├── paragraph-test.md
        │   │           ├── trivial-expected.json
        │   │           └── trivial-test.md
        │   ├── operations/
        │   │   └── plus-minus.spec.ts
        │   ├── opt-and-rep/
        │   │   ├── forever-parse.spec.ts
        │   │   ├── forever-parse.worker.mjs
        │   │   ├── opt.spec.ts
        │   │   ├── optrep.spec.ts
        │   │   └── rep.spec.ts
        │   ├── tuple/
        │   │   └── tuple.spec.ts
        │   └── tuple-parser/
        │       └── tuple-parser.spec.ts
        └── test/
            ├── data/
            │   ├── option.spec.js
            │   ├── try.spec.js
            │   └── tuple.spec.js
            ├── genlex/
            │   ├── genlex-brainfuck.spec.js
            │   ├── genlex-coverage.spec.js
            │   ├── genlex-event-tracer.spec.js
            │   ├── genlex-nospace.spec.js
            │   ├── genlex-priority.spec.js
            │   ├── genlex-tracer-minimal.spec.js
            │   ├── genlex.spec.js
            │   ├── tracing-genlex-coverage.spec.js
            │   └── tracing-genlex-flush.spec.js
            ├── parsec/
            │   ├── chars-bundle-regex.spec.js
            │   ├── chars-bundle-test.spec.js
            │   ├── f-layer-test.spec.js
            │   ├── flow-bundle-test.spec.js
            │   ├── flow-move-until.spec.js
            │   ├── flow-regex-flags.spec.js
            │   ├── flow-regex.spec.js
            │   ├── flow-try-or.spec.js
            │   ├── number-bundle-test.spec.js
            │   ├── parser-tuple-map.spec.js
            │   ├── parser_chain_test.spec.js
            │   ├── parser_core_default_test.spec.js
            │   ├── parser_core_test.spec.js
            │   ├── parser_extensions_test.spec.js
            │   ├── parser_stream_test.spec.js
            │   ├── response_test.spec.js
            │   └── tuple-parser-test.spec.js
            ├── specific/
            │   └── f-empty-try.spec.js
            └── stream/
                ├── array-stream-test.spec.js
                ├── buffered_stream_test.spec.js
                ├── offset-test.spec.js
                └── stream_test.spec.js

================================================
FILE: ingest/README.md
================================================
# Masala Parser: Javascript Parser Combinators

[![npm version](https://badge.fury.io/js/%40masala%2Fparser.svg)](https://badge.fury.io/js/%40masala%2Fparser)
[![Coverage Status](https://coveralls.io/repos/d-plaindoux/masala-parser/badge.png?branch=master)](https://coveralls.io/r/d-plaindoux/masala-parser?branch=master)
[![stable](http://badges.github.io/stability-badges/dist/stable.svg)](http://github.com/badges/stability-badges)

Masala Parser is an Open source javascript library to create your own parsers.
You won't need theoretical bases on languages for many usages.

Masala Parser shines for **simplicity**, **variations** and **maintainability**
of your parsers. Typescript support and token export for AI processing will also
help you in the debug process.

![absolute-demo.png](documentation/images/absolute-demo.png)

Masala Parser started in 2016 as a Javascript implementation of the Haskell
**Parsec** and is inspired by the paper titled:
[Direct Style Monadic Parser Combinators For The Real World](https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/parsec-paper-letter.pdf).

It is plain Javascript that works in the browser, is tested with more than 500
unit tests, covering 100% of code lines.

### Use cases

Here are the pros of Masala Parser:

- It can create a **full parser from scratch**
- It can **replace complex regexp**
- It works in any **browser** or NodeJS
- There is an **incredible typescript** api
- It has some **good performances** in speed and memory
- There is zero dependency
- Masala is actively supported by [Robusta Build](https://www.robusta.build)

# Usage

We made a **7 minutes** Youtube video to explain how to create a parser:

[![Masala Parser Youtube Video](documentation/images/masala-yt.png)](https://www.youtube.com/watch?v=VNUrvWdtM2g)

### Installation

With Node Js or modern build

        npm install -S @masala/parser
        yarn add @masala/parser

Or in the browser, using Javascript ES Modules:

        import {F, standard, Streams} from 'https://unpkg.com/@masala/parser@2.0.0

- [download Release](https://github.com/d-plaindoux/masala-parser/releases)
- `<script src="masala-parser.min.js"/>`

Check the [Change Log](./changelog.md) if you can from a previous version.

# Quick Examples

## Hello World

Let's parse `Hello World`

```js
const helloParser = C.string('Hello')
const white = C.char(' ')
const worldParser = C.string('World')
const combinator = helloParser.then(white.rep()).then(worldParser)
```

## Parsing tokens

You can parse a stream of tokens, not only characters. Let's parse a date from
tokens.

```js
import { Stream, C, F, GenLex } from '@masala/parser'

const genlex = new GenLex()

const [slash] = genlex.keywords(['/'])
// 1100 is the precedence of the token
const number = genlex.tokenize(N.digits(), 'number', 1100)

let dateParser = number
    .then(slash.drop())
    .then(number)
    .then(slash.drop())
    .then(number)
    .map(([day, , month, year]) => ({
        day: day,
        month: month,
        year: year,
    }))
```

You will then be able to combine this date parser with other parsers that use
the tokens.

Overall, using GenLex and tokens is more efficient than using characters for
complex grammars.

## Explanations

We create small simple parsers, with a set of utilities (`C`, `N`, `optrep()`,
`map()`, ...), then we create a more complex parser that combine them.

According to Wikipedia _"in functional programming, a parser combinator is a
higher-order function that accepts several parsers as input and returns a new
parser as its output."_

## The Parser

Let's say we have a document :

> The **James Bond** series, by writer **Ian Fleming**, focuses on a fictional
> _British_ secret service agent created in 1953.

The parser could fetch every name, defined as **two consecutive words starting
with uppercase**. The parser will read through the document and aggregate a
Response, which contains a value and the current offset in the text.

This value will evolve when the parser will meet new characters, but also with
some function calls, such as the `map()` function.

![Parser monoid](./documentation/parser-monoid.png)

## The Response

By definition, a Parser takes text as an input, and the Response is a structure
that represents your problem. After parsing, there are two subtypes of
`Response`:

- `Accept` when it found something.
- `Reject` if it could not.

```js
let response = C.char('a').rep().parse(Stream.ofChars('aaaa'))
assertEquals(response.value.join(''), 'aaaa')
assertEquals(response.offset, 4)
assertTrue(response.isAccepted())
assertTrue(response.isConsumed())

// Partially accepted: 'aa' is read, then it stops at offset 2
response = C.char('a').rep().parse(Stream.ofChars('aabb'))
assertEquals(response.value.join(''), 'aa')
assertEquals(response.offset, 2)
assertTrue(response.isAccepted())
assertFalse(response.isConsumed())
```

## Building the Parser, and execution

Like a language, the parser is built then executed. With Masala, we build using
other parsers.

```js
const helloParser = C.string('hello')
const white = C.char(' ')
const worldParser = C.char('world')
const combinator = helloParser.then(white.rep()).then(worldParser)
```

There is a compiling time when you combine your parser, and an execution time
when the parser runs its `parse(stream)` function. You will have the `Response`
after parsing.

So after building, the parser is executed against a stream of token. For
simplicity, we will use a stream of characters, which is a text :)

## Hello Gandhi

The goal is to check that we have Hello 'someone', then to grab that name

```js
import { Stream, C } from '@masala/parser'

var helloParser = C.string('Hello')
    .then(C.char(' ').rep())
    .then(C.letters()) // succession of A-Za-z letters
    .last() // keeping previous letters

// val(x) is a shortcut for: parse(Stream.ofChars(x)).value
var value = helloParser.val('Hello Gandhi')

assertEquals('Gandhi', value)
```

# Parser Combinations

Let's use a real example. We combine many functions that return a new Parser.
And each new Parser is a combination of Parsers given by the standard bundles or
previous functions.

```js
import { Stream, N, C, F } from '@masala/parser'

const blanks = () => C.char(' ').optrep()

function operator(symbol) {
    return blanks()
        .drop()
        .then(C.char(symbol)) // '+' or '*'
        .then(blanks().drop())
        .single()
}

function sum() {
    return N.integer()
        .then(operator('+').drop())
        .then(N.integer()) // then(x) creates a tuple - here, one value was dropped
        .map((tuple) => tuple.at(0) + tuple.at(1))
}

function multiplication() {
    return N.integer()
        .then(operator('*').drop())
        .then(N.integer())
        .array() // we can have access to the value of the tuple
        .map(([left, right]) => left * right) // more modern js
}

function scalar() {
    return N.integer()
}

function combinator() {
    return F.try(sum())
        .or(F.try(multiplication())) // or() will often work with try()
        .or(scalar())
}

function parseOperation(line) {
    return combinator().parse(Stream.ofChars(line))
}

assertEquals(4, parseOperation('2   +2').value, 'sum: ')
assertEquals(6, parseOperation('2 * 3').value, 'multiplication: ')
assertEquals(8, parseOperation('8').value, 'scalar: ')
```

A curry paste is a higher-order ingredient made from a good combination of
spices.

![](./documentation/images/curry-paste.jpg)

## Precedence

Precedence is a technical term for priority. Using:

```js
function combinator() {
    return F.try(sum())
        .or(F.try(multiplication())) // or() will often work with try()
        .or(scalar())
}

console.info('sum: ', parseOperation('2+2').value)
```

We will give priority to sum, then multiplication, then scalar. If we had put
`scalar()` first, we would have first accepted `2`, then what could we do with
`+2` alone ? It's not a valid sum ! Moreover `+2` and `-2` are acceptable
scalars.

## Backtracking with the parser: try(x).or(y)

Take a look at 2+2 and 2*2. These two operations *start with the same\*
character `2` ! The parser may try one operation and fail. Often, you will want
to go back to the initial offset and try another operation : That mechanism is
called [backtracking](https://en.wikipedia.org/wiki/Backtracking).

`try(x).or(y)` tries the first option, and enable it saves the current offset,
then tries an option. And as soon that it's not satisfied, it goes back to the
original offset and use the parser inside the `.or(P)` expression.`.

Let see how with `try()`, we can look a bit ahead of next characters, then go
back:

        F.try(sum()).or(F.try(multiplication())).or(scalar())
        // try(sum()) parser in action
        2         *2
        ..ok..ok  ↑oups: go back and try multiplication. Should be OK.

Suppose we do not `try()` but use `or()` directly:

        sum().or(multiplication()).or(scalar())
        // testing sum()
        2         *2
        ..ok..ok  ↑oups: cursor is NOT going back. So now we must test '*2' ;
                                                   Is it (multiplication())? No ;
                                                   or(scalar()) ? neither

We have the same problem with pure text. Let's parse `monday` or `money`

    const parser = C.string('monday').or('money')
    const result = parser.val('money')
                                  ^will stop ready `monday` at `e`

The result will be undefined, because the parser will not find `monday` neither
`money`. The good parser is:

    const parser = F.try(C.string('monday')).or('money')

When failing reading `monday`, the parser will come back to `m`

# Recursion

Masala-Parser (like Parsec) is a top-down parser and doesn't like
[Left Recursion](https://cs.stackexchange.com/a/9971).

However, it is a resolved problem for this kind of parsers. You can read more on
[recursion with Masala](./documentation/recursion.md), and checkout examples on
our Github repository (
[simple recursion](integration-ts/examples/lazy/transmission.spec.ts), or
[calculous expressions](integration-ts/examples/operations/plus-minus.spec.ts)
).

# Simple documentation of Core bundles

## Core Parser Functions

Here is a link for
[Core functions documentation](./documentation/parser-core-functions.md).

It will explain `then()`, `drop()`, `map()`, `rep()`, `opt()` and other core
functions of the Parser with code examples.

###

## The Chars Bundle

Example:

```js
C.char('-').then(C.letters()).then(C.char('-'))
// accepts  '-hello-' ; value is ['-','hello','-']
// reject '-hel lo-' because space is not a letter
```

[General use](./documentation/chars-bundle.md)

- `letter()`: accept a european letter (and moves the cursor)
- `letters()`: accepts many letters and returns a string
- `letterAs(symbol)`: accepts a european(default), ascii, or utf8 Letter.
  [More here](./documentation/chars-bundle.md)
- `lettersAs(symbol)`: accepts many letters and returns a string
- `emoji()`: accept any emoji sequence.
  [Opened Issue](https://github.com/d-plaindoux/masala-parser/issues/86).
- `notChar(x)`: accept if next input is not `x`
- `char(x)`: accept if next input is `x`
- `charIn('xyz')`: accept if next input is `x`, `y` or `z`
- `charNotIn('xyz')`: accept if next input is not `x`, `y` or `z`
- `subString(length)`: accept any next _length_ characters and returns the
  equivalent string
- `string(word)`: accept if next input is the given `word`
- `stringIn(words)`: accept if next input is the given `words`
  [More here](./documentation/chars-bundle.md)
- `notString(word)`: accept if next input is _not_ the given `word`
- `charLiteral()`: single quoted char element in C/Java : `'a'` is accepted
- `stringLiteral()`: double quoted string element in java/json: `"hello world"`
  is accepted
- `lowerCase()`: accept any next lower case inputs
- `upperCase()`: accept any next uppercase inputs

Other example:

```js
C.string('Hello').then(C.char(' ')).then(C.lowerCase().rep().join(''))

// accepts Hello johnny ; value is ['Hello', ' ', 'johnny']
// rejects Hello Johnny : J is not lowercase ; no value
```

## The Numbers Bundle

- `number()`: accept any float number, such as -2.3E+24, and returns a float
- `digit()`: accept any single digit, and returns a **number**
- `digits()`: accept many digits, and returns a **number**. Warning: it does not
  accept **+-** signs symbols.
- `integer()`: accept any positive or negative integer

## The Flow Bundle

The flow bundle will mix ingredients together.

For example, if you have a Parser `p`, `F.not(p)` will accept anything that does
not satisfy `p`

All of these functions will return a brand new Parser that you can combine with
others.

Most important:

- `F.try(parser).or(otherParser)`: Try a parser and come back to `otherParser`
  if failed
- `F.any()`: Accept any character (and so moves the cursor)
- `F.not(parser)`: Accept anything that is not a parser. Often used to accept
  until a given _stop_
- `F.eos()`: Accepted if the Parser has reached the **E**nd **O**f **S**tream
- `F.moveUntil(string|stopParser)`: Alternative for **regex**. Will traverse the
  document **until** the _stop parser_
    - returns `undefined` if _stop_ is not found
    - returns all characters if _stop_ is found, and set the cursor at the spot
      of the stop
- `F.dropTo(string|stopParser)`: Will traverse the document **including** the
  _stop parser_

Others:

- `F.lazy(parser, ?params)`: Makes a lazy evaluation. May be used for Left
  recursion (difficult)
- `F.parse(parserFunction)`: Create a new Parser from a function. Usually, you
  won't start here.
- `F.subStream(length)`: accept any next characters
- `F.returns(value)`: forces a returned value
- `F.error()`: returns an error. Parser will never be accepted
- `F.satisfy(predicate)`: check if condition is satisfied
- `F.startsWith(value)`: create a no-op parser with initial value

## License

Copyright (C)2016-2025 Didier Plaindoux & Nicolas Zozol

This program is free software; you can redistribute it and/or modify it under
the terms of the GNU Lesser General Public License as published by the Free
Software Foundation; either version 2, or (at your option) any later version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License along
with this program; see the file COPYING. If not, write to the Free Software
Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.

## Support

Masala Parser is maintained by [Robusta Build](https://www.robusta.build).
Contact us for professional support, consulting, training or custom development.



================================================
FILE: ingest/documentation/chain.md
================================================
Chain
====

Purpose
----

The goal of chaining is to create an higher level of parser. Instead of 
reading characters, it will read tokens.







================================================
FILE: ingest/documentation/chars-bundle.md
================================================
# Parser Combinator: Chars Bundle

## General Use

Using Only Chars

```js
import { Stream, F, C } from '@masala/parser'

let stream = Stream.ofChars('abc')
const charsParser = C.char('a')
    .then(C.char('b'))
    .then(C.char('c'))
    .then(F.eos().drop()) // End Of Stream ; droping its value, just checking it's here
let parsing = charsParser.parse(stream)

assertArrayEquals(['a', 'b', 'c'], parsing.value)
```

Or just using `C.letter` and `rep()`:

```js
stream = Stream.ofChars('Hello World')
const letterParser = C.letter
    .rep() // 'Hello'
    .then(C.char(' ')) // space is not a letter
    .then(C.letter.rep()) // 'World'

parsing = letterParser.parse(stream)
console.log(parsing.value)
//[ List { value: [ 'H', 'e', 'l', 'l', 'o' ] },' ',List { value: [ 'W', 'o', 'r', 'l', 'd' ] } ]
// Well, complicated value ; Note that rep() returns a masala-List structure
```

We can improve our control by using the right function at the right time. Here,
Using `C.letters` and `C.string`

```js
stream = Stream.ofChars('Hello World')
const helloParser = C.string('Hello').then(C.char(' ')).then(C.letters)

parsing = helloParser.parse(stream)
assertArrayEquals(['Hello', ' ', 'World'], parsing.value)
```

## Detailed functions

### `letterAs(symbol)`:

```js
import { Stream, F, C } from 'masala-parser'

assertTrue(C.letterAs().parse(Stream.ofChars('a')).isAccepted())
assertTrue(
    C.letterAs(C.OCCIDENTAL_LETTER).parse(Stream.ofChars('a')).isAccepted(),
)
assertTrue(C.letterAs(C.UTF8_LETTER).parse(Stream.ofChars('Б')).isAccepted())
assertTrue(
    !C.letterAs(C.OCCIDENTAL_LETTER).parse(Stream.ofChars('÷')).isAccepted(),
)
```

### stringIn

```js
stream = Stream.ofChars('James')
const combinator = C.stringIn(['The', 'James', 'Bond', 'series'])
parsing = combinator.parse(stream)
assertEquals('James', parsing.value)
```

### inRegexRange

C.inRegexRange(range) converts one character-class into a single–character
parser. The argument can be either a raw range string `a-zA-Z_` or a RegExp
`/[0-9A-Fa-f]/`. Internally it is anchored with ^…$, so the parser always
consumes exactly one code unit.

```js
let stream = Stream.ofChars('myUser')

//identifier parser-> myUser: ok ; 0myUser: not ok
const firstChar = C.inRegexRange('a-zA-Z_')
const restChars = C.inRegexRange('a-zA-Z0-9_').rep()
const identifier = firstChar.then(restChars)
```

For complex regex, you will probably prefer `F.regex()`.



================================================
FILE: ingest/documentation/flow-bundle.md
================================================
# Parser Combinator: Flow Bundle

## regex

F.regex(rgx) turns a JavaScript RegExp into a primitive parser. It supports
flags, look-ahead and all native JavaScript regex features.

```js
function assignParser() {
    const identifier = F.regex(/[a-zA-Z_][a-zA-Z0-9_]*/)
    const space = F.regex(/\s+/)
    const assign = C.string(':=')
    return identifier
        .then(space.optrep().drop())
        .then(assign)
        .then(space.optrep().drop())
        .then(identifier)
}
```

## Lazy

In functional programming, we call a lazy function a function that does not
evaluate immediately its argument. It's called lazy because it will run only
when needed.

In masala-parser, we use this concept to avoid infinite recursion. When we build
the parser, we don't know what is the input. And the recursion will end
depending on the input offset.

In that example, we would have an infinite recursion without lazy:

```js
function A() {
    return C.char('A').then(B())
}

function B() {
    return C.char('B').or(F.lazy(A))
}
```

Some parameters might be needed. In this case, params must be \*\*packed in an
array.

```js
function A(param) {
    return C.char(param).then(B())
}

function B() {
    return C.char('B').or(F.lazy(A), ['A'])
}
```

In some case, your parser is a function of a class, and this class must access
to `this`. A third parameter allows you to define who is `this`.

```js
class SomeLazyParser {
    constructor(char) {
        this.char = char
    }

    // first needs to know who is 'this'
    first() {
        return C.char(this.char).then(
            this.second()
                .opt()
                .map((opt) => opt.orElse('')),
        )
    }

    // Lazy call
    second() {
        return C.char('B').then(F.lazy(this.first, ['A'], this))
    }
}

const combinator = new SomeLazyParser('A').first().then(F.eos().drop())
```

## Extraction

`F.moveUntil(string|string[]|parser, include=false)` allows to quickly find data
in a document. `F.dropTo(string|parser)` will do the same, but dropping the
content.

```js
const line = Stream.ofChars('I write until James Bond appears')

const combinator = F.moveUntil(C.string('James'))
    .then(F.dropTo('appears'))
    .then(F.eos().drop())
const value = combinator.parse(line).value

test.equals(value, 'I write until ') // include set to false by default
```



================================================
FILE: ingest/documentation/genlex.md
================================================
Genlex Todos
=====

* tokens: as seen with other parsers, token functions should not be called to early
 or it will start a lot of unnecessary functions.
* class Token very strange
* each token should have a decent toString()
* 



Equivalence
=====

For simple case

        let genlex = new GenLex();
        genlex.setSeparatorsParser(eol().then(eol().rep()));
        const tkBullets = genlex.tokenize(bulletBlock(), 'bulletBlock',500);
        const parser = F.any().rep();
        
        
Is equivalent to

        let separators = eol().then(eol().rep());                
        let any = separators.optrep().then(bulletBlock()).then(separators.optrep());
        let parser = any.rep();
        

So it might be good to use the second form if stuck when debugging with Genlex. 

GenLex is more interesting when the parser is not `F.any()`.


================================================
FILE: ingest/documentation/numbers-bundle.md
================================================
# Parser Combinator: Numbers Bundle

**Import**

```ts
import { N, Stream } from '@masala/parser'
```

## Number parser

- `N.number()` → parses a **signed decimal** number (optional fraction, optional
  exponent).
- Grammar (informal):
  `[+-]? ( digits ( "." digits? )? | "." digits ) ( [eE] [+-]? digits )?`

The parsing is returned as a JavaScript type `number`.

**Notes**

- No implicit whitespace skipping. Trim or compose explicitly.
- Decimal only: **no** hex (`0x`), octal, binary, underscores, `Infinity`, or
  `NaN`.

**Examples**

```ts
N.number().parse(Stream.ofChars('42')) // → 42
N.number().parse(Stream.ofChars('-12.5')) // → -12.5
N.number().parse(Stream.ofChars('3.1e-2')) // → 0.031
```

Grammar: `[+-]? (digits ("." digits?)? | "." digits) ([eE][+-]?digits)?`

**Composing**

```ts
const ratio = N.number().then(C.char('/')).then(N.number())
// parses "12/7", returns a tuple-like chain per your combinator semantics
```

## digits()

- `N.digit()` → one ASCII digit `0–9`; returns a char.
- `N.digits()` → one-or-more digits; returns a string.

**Examples**

```ts
N.digit().parse(Stream.ofChars('7')) // '7'
N.digits().parse(Stream.ofChars('1234')) // '1234'
```



================================================
FILE: ingest/documentation/parser-core-functions.md
================================================
# Parser Object :

- It reads a stream of characters
    - The parser has functions to validate the stream
    - You can build your Parser by adding specific functions
- The Parser is a monoid
    - It wraps one (and only one) **value**
    - It has some functions to work on that value

## Streaming inputs

- The Parser is constructed with a Streaming function
- The Parser will consume **elements** form the stream
- The stream will stop if the Parser can't match the next element
    - state of the Parser will be `Rejected`
- If the Stream finishes, state of the Parser is `Accepted`
- Once a **element** is **consumed**, the Parser can't go back
    - this allows speed and above all low memory use

## Parser constructor

Usually, you would **NOT** create a Parser from its constructor. You will
combine **existing parsers** to create a new one. However it can solve specific
problems when combining existing parser is too difficult or not efficient.

```js
const newParser = new Parser(parseFunction)
// But don't do that, except if you know what you are doing
```

- construct a Parser object
- `parseFunction` is a streaming function
    - reads characters at a given index
    - can end the stream
- the `parseFunction` function will determine the behaviour of the Parser

Here is an example of a home-made parser for going back after an Accept:
[https://github.com/d-plaindoux/masala-parser/issues/138#issuecomment-49162720
5]

# Essential Parser functions

### then

- Construct a Tuple of values from previous accepted values

```js
let stream = Stream.ofChars('abc')
const charsParser = C.char('a')
    .then(C.char('b'))
    .then(C.char('c'))
    .then(F.eos().drop()) // End Of Stream ; droping its value, just checking it's here
let parsing = charsParser.parse(stream)
assertEquals(parsing.value, 'abc')
```

### drop()

- Uses `then()` and returns only the left or right value

```js
const stream = Stream.ofChars('|4.6|')
const floorCombinator = C.char('|')
    .drop()
    .then(N.number()) // we have ['|',4.6], we keep 4.6
    .then(C.char('|').drop()) // we have [4.6, '|'], we keep 4.6
    .map((x) => Math.floor(x))

// Masala needs a stream of characters
const parsing = floorCombinator.parse(stream)
assertEquals(4, parsing.value, 'Floor parsing')
```

`then()` and `drop()` will often be used to find the right value in your data.

### map(f)

- Change the value of the response

```js
const stream = Stream.ofChars('5x8')
const combinator = N.integer()
    .then(C.charIn('x*').drop())
    .then(N.integer())
    // values are [5,8] : we map to its multiplication
    .map((values) => values[0] * values[1])
assertEquals(combinator.val(stream), 40)
```

### returns(value)

- Forces the value at a given point
- It's a simplification of map

```js
const stream = Stream.ofChars('ab')
// given 'ac', value should be ['X' , 'c']
const combinator = C.char('a').returns('X').then(C.char('b'))
assertEquals(combinator.val(stream).array(), ['X', 'b'])
```

It could be done using `map()`, but `returns()` is more direct:

```js
const combinator = C.char('a')
    .map((anyVal) => 'X')
    .then(C.char('c'))
```

### thenEos()

- Test if the stream reaches the end of the stream

```js
const combinator = C.char('a')
C.char('a').thenEos()
```

It's important to note that the value will be moved in a Tuple, which is always
the case in a `thenXYZ` function

So if the parsing is accepted, the value will be `Tuple(['a'])`

### any()

- next character will always work
- consumes a character

### opt()

- Allows optional use of a Parser
- Internally used for `optrep()` function

```js
const P = parser
// ok for 'ac' but also 'abc'
C.char('a').opt(C.char('b')).char('c')
```

### rep()

- Ensure a parser is repeated **at least** one time

```js
const stream = Stream.ofChars('aaa')
const parsing = C.char('a').rep().parse(stream)
test.ok(parsing.isAccepted())
// We need to call list.array()
test.deepEqual(parsing.value.array(), ['a', 'a', 'a'])
```

`rep()` will produce a `List` of values. You can get the more standard array
value by calling `list.array()`

### optrep

- A Parser can be repeated zero or many times

```js
// ok for 'ac' but also 'abbbbbc'
C.char('a').optrep(C.char('b')).char('c')
```

There is a known issue with optrep: optrep().optrep() or optrep().rep() will
cause an infinite loop !

# Useful but touchy

`try()` and `or()` are useful, and work often together. `or()` alone is not
difficult, but it's harder to understand when it must work with `try()`

### or()

- Essential

`or()` is used to test a parser, and if it fails, it will try the next one

```js
const endLiner = C.char('\n').or(F.eos())
const parser = F.moveUntil(endLiner.drop())
```

This case is straightforward, but it can be more complex when the parser eats
while testing or().

```js
const eater = C.char('a').then(C.char('a'))
const parser = eater.or(C.char('b'))

const stream = Stream.ofChars('ab')
const parsing = parser.parse(stream)
expect(parsing.isAccepted()).toBe(false)
expect(parsing.offset).toBe(1) // ✨ this is the point ! one 'a' is consumed

const nonEater = F.try(eater).or(C.char('b')) // use this to allow backtracking
```

Because Masala is a fast LL(1) parser, it will try to move forward by default.

### partial and full backtracking: F.try().or() and F.tryAll()

- Essential !
- Try a succession of parsers
- If success, then continues
- If not, jump after the succession, and continues with `or()`

```js
const typical = F.try(x).or(y) // still no backtrack on or(y)
const manyOr = F.tryAll([x, y, z]) // same as try(x).or(try(y)).or(try(z))
```

### flatMap (f )

`flatMap` lets later parsing depend on earlier results. It runs a parser, then
feeds its value into `f(result)` to build the next parser—ideal for
context-sensitive checks and cross-references

Use `flatMap()` when plain sequencing isn’t enough.

- parameter f is a function
- Used when reading a data depends on previous data

Example of use case, where one author is given a rating

```
authors:Nicolas  # nameParser
Nicolas:5     # ratingParser
```

Here, `Nicolas` must be included in both lines to have a proper parsing.

Suppose we have a general `nameParser`, then a `ratingParser` could be used like
this:

```typescript
const separator = C.char(':')
const end = C.char('\n').opt()

const nameParser: SingleParser<string> = C.string('authors')
    .then(separator.drop())
    .then(C.letters())
    .then(end.drop())
    .last()

const ratingParser = (
    name: string, // name is from previous parsing
) =>
    C.letters()
        .filter((val: string) => val.includes(name)) // check name match
        .then(separator.drop())
        .then(
            F.not(end)
                .rep()
                .map((chars) => chars.join('')),
        )

const parser = nameParser.flatMap(ratingParser)

const string = `authors:Nicolas\nNicolas:5`
const value = parser.val(string)
expect(value.array()).toEqual(['alice', '5'])
```

It can help you to read your document knowing what happen previously

### filter (predicate)

- To be used once a value is defined
- `predicate` is a function pVal -> boolean
- Check if the stream satisfies the predicate
    - Parse will be `Rejected` if filter is `false`

        'expect (filter) to be accepted': function(test) {
        test.equal(parser.char("a").filter(a => a === 'a')
        .parse(Stream.ofChars("a")).isAccepted(), true, 'should be accepted.');
        }

### match (matchValue)

- Simplification of `filter()`
- Check if the stream value is equal to the _matchValue_

                                //given 123
                                N.number().match(123)

### error()

- Forces an error
- The parser will be `rejected`

### satisfy(predicate)

- Used internally by higher level functions
- If predicate is true, consumes a element from the stream, and the value is set
  to the element
- If predicate is false, the element is not consumed



================================================
FILE: ingest/documentation/parser-extension-functions.md
================================================
# Parser Extensions

These functions allow users to quickly find letters or numbers in a standard
text

### returns()

- Forces a value
- Does not consume a character

### lazy(parserFunction)

- The point is that the parserFunction is not called immediately
    - Use `F.lazy( this.text )` and not `F.lazy( this.text() )`
- The parserFunction will be called when needed
- One important use is [when dealing with **recursion**](./recursion.html)

           expression() {
                    return F.try(
                        number()
                            .thenLeft(plus())
                            .then(F.lazy(  expression ) )  // <-- function is not called
                            .map(values => values[0]+values[1])
                    )
                    .or(this.number());
            }

Important : Masala is a streaming parser.
[The grammar you make a parser for can NOT be left recursive.](https://github.com/d-plaindoux/masala-parser/issues/13)
The good news is that any left recursive grammar can be rewritten to a form that
masala-parser can handle.



================================================
FILE: ingest/documentation/publish.md
================================================
This document is for contributors who want to publish. You must have correct ssh
key

## Integration test at lower level

TL;DR: run `npm run compile` then `node tasks/integrate.js`

`npm run compile` will compile files with babel; `package.json` says users will
import

        "main": "build/index.js",

then `tasks/post-compile` will copy json files needed for unit and performance
tests.

`npm run prepublish` will make a few integration test with this compiled
version.

These prepublish tests cant be run independently with `node tasks/integrate.js`

### Make a pre-release to test stuff

then level-up the version number in package.json

        "version": "2.1.0-alpha1",

Check compile, and deploy locally to `integration-ts folder`

        npm run cover # check 100% is covered
        npm run dist  # build and copy the files
        npm run integration # copy files to integration folder and run the integration tests

It should print the test results

then you can publish

        npm publish  --access=public

If work :

- Set tag on github. On branch master :
- Change version on package.json
- commit & push
- `git tag v2.1.0 master`
- `git push origin v2.1.0`
- `npm publish  --access=public`

Warning: You cannot unpublish easily after 72 hours, but you can deprecate the
package



================================================
FILE: ingest/documentation/recursion.md
================================================
# Recursion

Masala-Parser (like Parsec) is a top-down parser and doesn't like
[Left Recursion](https://cs.stackexchange.com/a/9971). Furthemore, building
naively your combinator parser with recursion would make a stack overflow before
parsing

## Recursion fail

        const {Stream, F, N, C, X} = require('@masala/parser');

        function A(){
            return C.char('A').then(B());
        }

        function B(){
            return C.char('B').or(A()); //   <----- will call A() then B() then A()
        }

        console.log('=== Building Parser ====');
        const parser = A();
        console.log('=== NEVER THERE ====');
        let parsing = parser.parse(Stream.ofChars('AAAAAB'));

## Lazy Recursion

**Masala-Parser** Comes with a `F.lazy( P )` function that will end the loop
while building. It builds the combinator, but P will be called only while
parsing the stream.

        function A(){
            return C.char('A').then(B());
        }

        function B(){
            return C.char('B').or(F.lazy(A));  <--- A() is not called yet !
        }

        console.log('=== Building Parser ====');
        const parser = A();
        console.log('=== GETTING THERE ====');
        let parsing = parser.parse(Stream.ofChars('AAAAAB')); // Accepted :)

## Operations

Operation are logically left-recursive: Let say an expression is `100` or
`(20*5)`, which is also `((4*5)*5)`, or `(((2*2)*5)*5)` ....

There is a general algorithm that
[removes Left recursion](https://en.wikipedia.org/wiki/Left_recursion#Removing_left_recursion).

It can be written it his PEG form:

        E -> T E'
        E' -> + TE'  |  eps
        T -> F T'
        T' -> * FT'  |  eps
        F -> NUMBER | ID | ( E )

Where:

- **E** is an Expression
- **F** is a terminal expression (Final), or a start for recursion
- **E'** and **T'** are optional operation made on **F**
- eps is an empty character

Note that there are two distinct level of precedence, as `+` and `*` doesn't
have the same level of priority. Using only one level of operator, we simplify
to:

        T -> F T'
        T' -> operator FT'  |  eps
        F -> NUMBER | ( T )

Which can be translated in _pseudo masala_:

        expr -> terminal then subExpr
        subExpr -> (operator then terminal then subExpr ).opt()
        terminal -> NUMBER or ( F.lazy(expr) )

It appears that it's simplified with Masala, as you won't have to create a
subExpression per operator. Just call

        const operator = ()=> C.charIn('+-*/');



================================================
FILE: ingest/documentation/troubleshooting.md
================================================
# Troubleshooting

## Debug

- Every Parser has a `debug(comment, showValue)` function
- If the parser is Accepted at this point, the debug comment shows off

```js
const floorCombinator = C.string('Hello')
    .then(C.string(' World'))
    .debug('Found')
    .then(C.string('fail'))
    .debug('wont be displayed', true)

const parsing = floorCombinator.parse(Stream.ofChars('Hello World !!!'))
assertFalse(parsing.isAccepted(), 'Testing debug')
```



================================================
FILE: ingest/documentation/tuple.md
================================================
# Tuple and TupleParser

## Tuple

A tuple is a data structure that contains a sequence of elements, each of which
can be of a different type. In Masala Parser, Tuples are used to group related
data together and are particularly useful for handling parser results.

The very special thing of tuple is that they merge together (see below).

Most examples will show the types, but they are usually automatically inferred.

### Creating Tuples

There are two main ways to create a tuple:

```typescript
// Create an empty tuple
const emptyTuple: EmptyTuple = tuple()

// Create a tuple from an array
const numberTuple: Tuple<number> = tuple([1, 2, 3])

// tuples are immutable. Adding elements will create a new tuple
const more: Tuple<number> = numberTuple.append(4)
```

### Tuple Interface

The Tuple interface provides several methods for working with the contained
values:

```typescript
export interface Tuple<T> {
    // The underlying array of values
    value: T[]

    isEmpty(): boolean
    size(): number

    // Get first element (throws if empty)
    single(): T

    // Get all elements as an array
    array(): T[]

    last(): T
    first(): T
    at(index: number): T

    // Join elements with optional separator
    join(separator?: string): string

    // Append elements or other tuples
    append(neutral: NEUTRAL): this
    append<Y>(other: Tuple<Y>): Tuple<T | Y>
    append<Y>(element: Y): Tuple<T | Y>
}
```

An EmptyTuple is a Tuple that contains the `NEUTRAL` value. It looks unusual,
but this information was needed to ensure proper merging.

### Examples

```typescript
// Basic tuple operations
const t1 = tuple(['a', 'b', 'c'])
console.log(t1.size()) // 3
console.log(t1.first()) // 'a'
console.log(t1.last()) // 'c'
console.log(t1.at(1)) // 'b'
console.log(t1.join('-')) // 'a-b-c'

// Combining tuples
const t2 = tuple(['x', 'y'])
const combined = t1.append(t2)
console.log(combined.array()) // ['a', 'b', 'c', 'x', 'y']

// Single value access
const singleTuple = tuple(['value'])
console.log(singleTuple.single()) // 'value'
```

## Type inference

Thought the library is written in pure javascript, a .d.ts provides the typing
and Tuples are typed as follows:

```typescript
const t = tuple() // Create an EmptyTuple
const nTuple = empty.append(2) // Create a Tuple<number>
const mixedTuple = nTuple.append('a') // Create a MixedTuple<number | string>
```

There are three types of Tuples:

1. **EmptyTuple**: Represents an empty tuple with no elements.
2. **Tuple<T>**: Represents a tuple containing elements of type T.
3. **MixedTuple<FIRST, LAST>**: Specify the first and last element types

Defining correctly MixedTuples is important as Parsers often drop most elements.

Types of `first()` and `last()` are also inferred.

```typescript
const first: number = mixedTuple.first() // number 2
const last = mixedTuple.last() // string 'a', no need to specify type
```

## Tuple merge with Tuple

That's the very power of Tuples.

- Adding a `number` ot a `Tuple<number>` will still be a `Tuple<number>`.
- Adding a string to a `Tuple<number>` will create a
  `MixedTuple<number , string>`.
- Adding a `Tuple<number>` to a `Tuple<number>` NOT be a
  `Tuple<number , Tuple<number>>` but still a `Tuple<number>`.

```typescript
const tuple1: Tuple<number> = tuple([1, 2, 3])
const tuple2: Tuple<number> = tuple([4, 5, 6])
const merged: Tuple<number> = tuple1.append(tuple2)
expect(merged.first()).toBe(1)
expect(merged.last()).toBe(6)
expect(merged.at(3)).toBe(4)
```

Therefore, a Tuple<T> merged with an EmptyTuple will still be a Tuple<T>.



================================================
FILE: ingest/examples/index.ts
================================================
import './1-easy/chars'
import './1-easy/hello-something'
import './1-easy/number'
import './1-easy/floor'
import './1-easy/response'
import './2-medium/f-layer'
import './2-medium/filter-match'
import './2-medium/flat-map'
import './brainfuck/compiler'
import './chars/letter-letterAs'
import './chars/charIn-notChar'
import './flow/try-with-no-or'
import './flow/not'
import './flow/nop-any-eos'
import './flow/startWith-moveUntil-dropTo'
import './lazy/transmission'
import './markdown/test/markdown-test'

import './operations/plus-minus'
console.log('Integration with Typescript perfect !')



================================================
FILE: ingest/examples/1-easy/chars.spec.ts
================================================
import { describe, it, expect } from 'vitest'
import { Stream, F, C } from '@masala/parser'

/**
 * Created by Nicolas Zozol on 05/11/2017.
 */
describe('Character parsers', () => {
    it('should parse sequential characters followed by EOS', () => {
        const stream = Stream.ofChars('abc')
        const charsParser = C.char('a')
            .then(C.char('b'))
            .then(C.char('c'))
            .then(F.eos().drop()) // End Of Stream ; dropping its value, just checking it's here
        let charsParsing = charsParser.parse(stream)
        expect(charsParsing.value.join('')).toBe('abc')
    })
})



================================================
FILE: ingest/examples/1-easy/floor.spec.ts
================================================
import { describe, it, expect } from 'vitest'
import { Stream, C, N } from '@masala/parser'

describe('Absolute parser', () => {
    it('should parse a number between pipes and make it positive', () => {
        // We parse the mathematical absolute expression: |-4.6|
        let stream = Stream.ofChars('|-4.6|')
        const absoluteParser = C.char('|')
            .then(N.number())
            .last() // we had ['|',-4.6], we keep -4.6
            // we take and immediately drop '|'
            .then(C.char('|').drop()) // we now have [-4.6]
            .single()
            .map((x) => Math.abs(x)) // we map -4.6 to 4.6

        // Masala needs a stream of characters
        let parsing = absoluteParser.parse(stream)
        expect(parsing.value).toBe(4)
    })
})



================================================
FILE: ingest/examples/1-easy/hello-something.spec.ts
================================================
import { Stream, C } from '@masala/parser'
import { describe, it, expect } from 'vitest'

describe('Hello Something Parser', () => {
    it("should parse 'Hello 'World''", () => {
        const helloParser = C.string('Hello')
            .then(C.char(' ').rep())
            .then(C.char("'"))
            .drop()
            .then(C.letter().rep()) // keeping repeated ascii letters
            .then(C.char("'").drop()) // keeping previous letters

        const parsing = helloParser.parse(Stream.ofChars("Hello 'World'"))
        // C.letter.rep() will giv a array of letters
        expect(parsing.value.array()).toEqual(['W', 'o', 'r', 'l', 'd'])
    })

    it("should parse 'Hello 'People' in 2017' but stop after People", () => {
        const helloParser = C.string('Hello')
            .then(C.char(' ').rep())
            .then(C.char("'"))
            .drop()
            .then(C.letter().rep()) // keeping repeated ascii letters
            .then(C.char("'").drop()) // keeping previous letters

        // Note that helloParser will not reach the end of the stream; it will stop at the space after People
        const peopleParsing = helloParser.parse(
            Stream.ofChars("Hello 'People' in 2017"),
        )

        expect(peopleParsing.value.join('')).toBe('People')
        expect(peopleParsing.offset).toBeLessThan(
            "Hello 'People' in 2017".length,
        )
    })
})



================================================
FILE: ingest/examples/1-easy/number.spec.ts
================================================
import { Stream, F, N } from '@masala/parser'
import { describe, it, expect } from 'vitest'

describe('Number parser', () => {
    it('should parse a number followed by EOS', () => {
        // Parsec needs a stream of characters
        const document = '12'
        const s = Stream.ofChars(document)

        // numberLitteral defines any int or float number
        // We expect a number, then eos: End Of Stream
        // We use drop() because we don't need the value of F.eos, we only want 12
        const numberParser = N.number().then(F.eos().drop()).single()
        const parsing = numberParser.parse(s)

        // If the parser reached the end of stream (F.eos) without rejection, parsing is accepted
        expect(parsing.isAccepted()).toBe(true)
        // The parser has a 12 value inside the monoid
        expect(parsing.value).toBe(12)
    })
})



================================================
FILE: ingest/examples/1-easy/occurence.spec.ts
================================================
import { Stream, C, N } from '@masala/parser'
import { describe, it, expect } from 'vitest'

describe('Occurrence parser', () => {
    it('should parse 5 occurrences of a digit', () => {
        let combinator = N.digit().occurrence(5)
        let response = combinator.parse(Stream.ofChars('55555'))

        expect(response.value.size()).toBe(5)
    })

    it('should parse 3 occurrences of a digit followed by a number', () => {
        // we are looking for 5,5,5 then 55
        let combinator = N.digit().occurrence(3).then(N.number())
        let response = combinator.parse(Stream.ofChars('55555'))

        expect(response.isAccepted()).toBe(true)
        expect(response.value.last()).toBe(55)
    })

    it('should parse 3 occurrences of "ab"', () => {
        /**
         * Occurence with a Tuple parser
         */
        let parser = C.char('a').then(C.char('b')).occurrence(3)
        let resp = parser.parse(Stream.ofChars('ababab'))

        // Expecting a structure like [['a','b'], ['a','b'], ['a','b']]
        expect(resp.isAccepted()).toBe(true)

        // Assuming the value structure holds the parsed sequence
        // This might need adjustment based on how occurrence bundles the results
        expect(resp.value.size()).toBe(6)
        expect(resp.value.at(0)).toEqual('a')
        expect(resp.value.at(1)).toEqual('b')
        expect(resp.value.at(2)).toEqual('a')
    })

    it('should fail until type resolved', () => {
        /**
         * Occurence with a Tuple parser
         */
        let parser = C.char('a').then(C.char('b')).occurrence(3)
        let resp = parser.parse(Stream.ofChars('ababab'))

        // Expecting a structure like [['a','b'], ['a','b'], ['a','b']]
        expect(resp.isAccepted()).toBe(true)

        // Assuming the value structure holds the parsed sequence
        // This might need adjustment based on how occurrence bundles the results
        expect(resp.value.size()).toBe(6)

        // TODO: expected error due to dad typing #180
        // expect(resp.value.at(0).array()).toEqual('a');
    })
})



================================================
FILE: ingest/examples/1-easy/response.spec.ts
================================================
import { Stream, C } from '@masala/parser'
import { describe, it, expect } from 'vitest'

describe('Parser Response', () => {
    it('should handle fully accepted response', () => {
        let response = C.char('a').rep().parse(Stream.ofChars('aaaa'))
        expect(response.value.join('')).toBe('aaaa')
        expect(response.offset).toBe(4)
        expect(response.isAccepted()).toBe(true)
        expect(response.isEos()).toBe(true)
    })

    it('should handle partially accepted response', () => {
        // Partially accepted
        let response = C.char('a').rep().parse(Stream.ofChars('aabb'))
        expect(response.value.join('')).toBe('aa')
        expect(response.offset).toBe(2)
        expect(response.isAccepted()).toBe(true)
        expect(response.isEos()).toBe(false)
    })
})



================================================
FILE: ingest/examples/2-medium/f-layer.spec.ts
================================================
import { describe, it, expect } from 'vitest'
import { Stream, F, C, N } from '@masala/parser'

describe('F Layer Combinators', () => {
    it('should parse alternatives using try and or', () => {
        const combinator = F.try(N.number())
            .or(C.string('hello'))
            .or(C.string('goodbye'))

        let response = combinator.parse(Stream.ofChars('goodbye'))
        expect(response.isAccepted()).toBe(true)
        // Check the value based on the expected type if needed
        // expect(response.value).toBe('goodbye');
    })

    it('should parse using F.layer and succeed when both parsers match', () => {
        const first = C.char('a').then(C.char('a')).eos()
        const second = C.string('aa').eos()

        const successInput = 'aa'
        const layer = F.layer(first).and(second)

        let layerResponse = layer.parse(Stream.ofChars(successInput))
        expect(layerResponse.isAccepted()).toBe(true)
        // Add expectation for the value if needed, depends on F.layer logic
        // e.g., expect(layerResponse.value)... depending on what F.layer returns
    })
})



================================================
FILE: ingest/examples/2-medium/filter-match.spec.ts
================================================
import { Stream, N } from '@masala/parser'
import { describe, it, expect } from 'vitest'

describe('Filter and Match Combinators', () => {
    it('should filter digits greater than or equal to 5', () => {
        let combinator = N.digit()
            .filter((m) => m >= 5)
            .rep()
        // The parser will accept the first 3 numbers (5, 6, 7)
        let response = combinator.parse(Stream.ofChars('5672'))
        expect(response.isAccepted()).toBe(true)
        expect(response.value.size()).toBe(3)
        // Check the actual values if needed
        // expect(response.value.array()).toEqual([5, 6, 7]);
    })

    it('should match the exact number 55', () => {
        /**
         * Match allow to find the right number
         */
        let parser = N.number().match(55)

        // Test case 1: exact match
        let res1 = parser.parse(Stream.ofChars('55'))
        expect(res1.isAccepted()).toBe(true)
        expect(res1.value).toBe(55)

        // Test case 2: non-match (extra digit)
        let res2 = parser.parse(Stream.ofChars('555'))
        expect(res2.isAccepted()).toBe(false)

        // Test case 3: non-match (different number)
        let res3 = parser.parse(Stream.ofChars('56'))
        expect(res3.isAccepted()).toBe(false)
    })
})



================================================
FILE: ingest/examples/2-medium/flat-map.spec.ts
================================================
import { Stream, C, N, SingleParser, F } from '@masala/parser'
import { describe, it, expect } from 'vitest'

// Next char must be the double of the previous
function doubleNumber(param: number) {
    return C.string('' + param * 2)
}

describe('FlatMap Combinator', () => {
    it('should parse a digit, then parse the string representation of its double', () => {
        const combinator = N.digit().flatMap(doubleNumber)

        // Test case 1: Successful parse (1 followed by 2)
        let response1 = combinator.parse(Stream.ofChars('12'))
        expect(response1.isAccepted()).toBe(true)
        // flatMap typically combines results. Check how the library handles this.
        // Assuming it keeps the second parser's result: expect(response1.value.join('')).toBe('2');
        // Or if it combines: expect(response1.value.array()).toEqual([1, '2']);

        // Test case 2: Failed parse (1 followed by 3, expected 2)
        let response2 = combinator.parse(Stream.ofChars('13'))
        expect(response2.isAccepted()).toBe(false)

        // Test case 3: Successful parse (4 followed by 8)
        let response3 = combinator.parse(Stream.ofChars('48'))
        expect(response3.isAccepted()).toBe(true)
        // Assuming it keeps the second parser's result: expect(response3.value.join('')).toBe('8');
    })

    it('should parse lines', () => {
        const separator = C.char(':')
        const end = C.char('\n').opt()

        const nameParser: SingleParser<string> = C.string('authors')
            .then(separator.drop())
            .then(C.letters())
            .then(end.drop())
            .last()

        const ratingParser = (name: string) =>
            C.letters()
                .filter((val: string) => val.includes(name))
                .then(separator.drop())
                .then(
                    F.not(end)
                        .rep()
                        .map((chars) => chars.join('')),
                )

        const parser = nameParser.flatMap(ratingParser)

        const string = `authors:alice\nalice:5`
        const value = parser.val(string)
        expect(value.array()).toEqual(['alice', '5'])

        /*const ratingParser = (nameParser: SingleParser<string>) => {
            return nameParser.filter(
                (val: string) => val.includes(val.name), // ✨
            )
        }
        */
    })
})



================================================
FILE: ingest/examples/2-medium/real-world-flatmap.spec.ts
================================================
import { Stream, C, N, F, SingleParser, TupleParser } from '@masala/parser'
import { describe, it, expect } from 'vitest'

interface FirstLine {
    name: string
    value: string[]
}

const document = `
authors: Nicolas, John
Nicolas: 5/10
---

# Masala Parser rocks!
`.trim()

const leftText = F.regex(/[a-zA-Z_][a-zA-Z0-9_]*/)
const separator = C.char(':')

const rightText = F.moveUntil(C.char('\n'), true).map((s) =>
    s.split(',').flatMap((x) => x.trim()),
)

const lineParser = leftText
    .then(separator.drop())
    .then(rightText)

    //.array()
    .map((tuple) => {
        const name = tuple.first()
        const values = tuple.last()
        return {
            name,
            value: values,
        }
    })

const secondLineParser = (firstLine: FirstLine) => {
    return lineParser.filter((val: FirstLine) =>
        firstLine.value.includes(val.name),
    )
}

const verifiedParser = lineParser.flatMap(secondLineParser)

describe('Flatmap real life case', () => {
    it('should parse a line', () => {
        const stream = Stream.ofChars(document)
        const parsing = verifiedParser.parse(stream)
        expect(parsing.isAccepted()).toBe(true)
        expect(parsing.value).toEqual({
            name: 'Nicolas',
            value: ['5/10'],
        })
        expect(parsing.isEos()).toBe(false)
    })
})



================================================
FILE: ingest/examples/brainfuck/compiler.spec.ts
================================================
import {
    C,
    F,
    GenLex,
    IParser,
    Option,
    SingleParser,
    Stream,
    Tuple,
    tuple,
    TupleParser,
} from '@masala/parser'
import { describe, it, expect } from 'vitest'

const genlex = new GenLex()
genlex.setSeparatorsParser(F.not(C.charIn('+-<>[],.')))
const [plus, minus, lt, gt, open, close, comma, period] = genlex.keywords([
    '+',
    '-',
    '<',
    '>',
    '[',
    ']',
    ',',
    '.',
])

const MEMORY_SIZE = 30000
const memory = new Array(MEMORY_SIZE).fill(0)

// Memory pointer (Points to a cell in MEMORY)
let pointer = 0

let executed = ''
let max = 0
let input = ''
let output = ''

interface Instruction {
    type: string
}

interface Loop extends Instruction {
    values: Tuple<Instruction>
}

function terminal(): TupleParser<Instruction> {
    return plus
        .or(minus)
        .or(lt)
        .or(gt)
        .or(comma)
        .or(period)
        .map((result) => ({ type: result.value }) as Instruction)
        .rep()
}

function loopExpr(): SingleParser<Loop> {
    return (
        open
            .drop()
            .then(F.lazy(expr))
            .then(close.drop())
            //.array()
            .map((values) => {
                return {
                    type: 'loop',
                    values,
                }
            })
    )
}

function expr(): TupleParser<Instruction> {
    //TODO: typing error

    const empty = tuple() as Tuple<Instruction>
    const sub: IParser<Option<Tuple<Instruction>>> = subExpr().opt()

    const mappedSub = sub.map((option) =>
        option.isPresent() ? option.get() : empty,
    ) as unknown as TupleParser<Instruction>

    return terminal().then(mappedSub) as TupleParser<Instruction>
}

function subExpr(): TupleParser<Instruction> {
    const lazy = F.lazy(expr)
        .opt()
        .map((option) =>
            option.isPresent() ? option.get() : tuple(),
        ) as IParser<Tuple<Instruction>>

    return loopExpr().then(lazy) as unknown as TupleParser<Instruction>
}

export function createParser() {
    const grammar = expr()
    return genlex.use(grammar)
}

// from https://gist.github.com/shawnmcla/
function brainfuck(program: string) {
    resetState()

    const parser = createParser()

    let response = parser.parse(Stream.ofChars(program))

    interpretAll(response.value)

    console.log({ memory: memory.slice(0, max + 1), output, executed })

    console.log('\n\n\n\n')
}

function interpretAll(instructions: Tuple<Instruction>) {
    instructions.array().forEach(interpret)
}

function interpret(instruction: Instruction) {
    switch (instruction.type) {
        case '>':
            if (pointer == max) {
                max++ // we need one more cell
            }
            pointer++
            break
        case '<':
            pointer--
            break
        case '+':
            memory[pointer]++
            break
        case '-':
            memory[pointer]--
            break
        case '.':
            sendOutput(memory[pointer])
            break
        case ',':
            memory[pointer] = getInput()
            break
        case 'loop':
            while (memory[pointer] !== 0) {
                executed += ' ' + instruction.type
                let loop = instruction as Loop
                interpretAll(loop.values)
            }
            break
        default: // We ignore any character that are not part of regular Brainfuck syntax
            break
    }
    if (instruction.type !== 'loop') {
        executed += ' ' + instruction.type
    }
}

function resetState() {
    //console.log('----- new brainfuck ------ \n\n  ')
    // Clear memory, reset pointers to zero.
    memory.fill(0)
    max = 0
    pointer = 0
    output = ''
    input = ''
    executed = ''
}

function sendOutput(value: number) {
    output += String.fromCharCode(value)
}

function getInput() {
    return 42
}

describe('Brainfuck Interpreter', () => {
    it('should handle simple increment and move', () => {
        const program = '+++>+'
        resetState()
        const parser = createParser()
        let response = parser.parse(Stream.ofChars(program))
        interpretAll(response.value)

        expect(memory.slice(0, max + 1)).toEqual([3, 1])
        expect(output).toBe('')
        expect(pointer).toBe(1)
    })

    it('should handle a simple loop for swap', () => {
        const program = '+++[>+<-]'
        resetState()
        const parser = createParser()
        let response = parser.parse(Stream.ofChars(program))
        interpretAll(response.value)

        // Memory: [0, 3] (values swapped), Pointer: 0
        expect(memory.slice(0, max + 1)).toEqual([0, 3])
        expect(output).toBe('')
        expect(pointer).toBe(0)
    })

    it('should print \"Hello World!\\n\"', () => {
        // Hello World program from https://esolangs.org/wiki/Brainfuck#Hello,_World!
        const program =
            '++++++++[>++++[>++>+++>+++>+<<<<-]>+>+>->>+[<]<-]>>.>---.+++++++..+++.>>.<-.<.+++.------.--------.>>+.>++.'
        resetState()
        const parser = createParser()
        let response = parser.parse(Stream.ofChars(program))
        interpretAll(response.value)

        expect(output).toBe('Hello World!\n')
        // Memory state check might be complex, focusing on output
    })

    // Add more tests for comma, period, edge cases etc.
})

/* Original direct calls - commented out
//simple test
brainfuck('+++>+');


//swap 0,1 values
brainfuck('+++[>+<-]');

let hW = '++++++++[>++++[>++>+++>+++>+<<<<-]>+>+>->>+[<]<-]>>.>---.+++++++..+++.>>.<-.<.+++.------.--------.>>+.>++.';
brainfuck(hW);
*/



================================================
FILE: ingest/examples/chars/charIn-notChar.spec.ts
================================================
import { Stream, C } from '@masala/parser'
import { describe, it, expect } from 'vitest'

describe('Character Combinators (charIn, charNotIn)', () => {
    it('charNotIn should parse characters not in the specified set', () => {
        let combinator = C.charNotIn('abc').rep()
        // will accept x, y, and z but will stop at 'b'
        let response = combinator.parse(Stream.ofChars('xyzb'))

        expect(response.isAccepted()).toBe(true)
        expect(response.offset).toBe(3)
        expect(response.value.join('')).toBe('xyz')
    })

    it('charIn should parse characters within the specified set until EOS', () => {
        let combinator = C.charIn('abc').rep().thenEos()
        let response = combinator.parse(Stream.ofChars('acbaba'))

        expect(response.isAccepted()).toBe(true)
        expect(response.value.join('')).toBe('acbaba')
        expect(response.isEos()).toBe(true)
    })
})



================================================
FILE: ingest/examples/chars/letter-letterAs.spec.ts
================================================
import { Stream, C } from '@masala/parser'
import { describe, it, expect } from 'vitest'

describe('Character Combinators (letters, lowerCase, notString)', () => {
    it('should parse sequences of letters and characters', () => {
        const inputString = 'The quick brown fox jumps over the lazy dog.'

        function combinator() {
            return C.letters() // Parses 'The'
                .then(C.char(' ')) // Parses space
                .then(C.lowerCase().rep()) // Parses 'quick'
                .then(C.char(' ')) // Parses space
                .then(C.notChar('.').rep()) // Parses until the end
        }

        let stream = Stream.ofChars(inputString)
        let parsing = combinator().parse(stream)

        expect(parsing.isAccepted()).toBe(true)
        const structure = parsing.value.array() as string[]
        expect(structure[0]).toBe('The') // Check the number of parsed elements
        expect(parsing.value.join('')).toBe(
            'The quick brown fox jumps over the lazy dog',
        ) // Check the collected value
        expect(parsing.isEos()).toBe(false) // Did not reach the '.' at EOS
    })
})



================================================
FILE: ingest/examples/flow/nop-any-eos.spec.ts
================================================
import { Stream, F, C } from '@masala/parser'
import { describe, it, expect } from 'vitest'

function day() {
    return C.stringIn([
        'MONDAY',
        'TUESDAY',
        'WEDNESDAY',
        'THURSDAY',
        'FRIDAY',
        'SATURDAY',
        'SUNDAY',
    ])
}

const string = '-MONDAY-'

function combinator() {
    return F.any().then(day()).then(F.nop()).then(F.any()).eos()
}

let stream = Stream.ofChars(string)
let parsing = combinator().parse(stream)

describe('Flow Combinators (nop, any, eos)', () => {
    it('should parse any, then day, then nop, then any, then eos', () => {
        expect(parsing.isAccepted()).toBe(true)
        expect(parsing.isEos()).toBe(true)
        // Value check depends on what eos() returns, often undefined or a special marker
        // expect(parsing.value)...
    })
})



================================================
FILE: ingest/examples/flow/not.spec.ts
================================================
import { Stream, F, C } from '@masala/parser'
import { describe, it, expect } from 'vitest'

describe('Flow Combinator (not)', () => {
    it('should succeed only when the inner parser fails, without consuming input', () => {
        function day() {
            return C.stringIn([
                'MONDAY',
                'TUESDAY',
                'WEDNESDAY',
                'THURSDAY',
                'FRIDAY',
                'SATURDAY',
                'SUNDAY',
            ])
        }

        function a() {
            return C.char('a')
        }

        const inputString = 'Xabx' // X matches not(day), fails not(a), fails not(day)

        let stream = Stream.ofChars(inputString)

        let parsing1 = F.not(day()).parse(stream)
        expect(parsing1.isAccepted(), "F.not(day()) on 'X'").toBe(true)
        expect(parsing1.offset, "F.not(day()) offset on 'X'").toBe(1)

        let parsing2 = F.not(a()).parse(stream)
        expect(parsing2.isAccepted(), "F.not(a()) on 'X'").toBe(true)
        expect(parsing2.offset, "F.not(a()) offset on 'X'").toBe(1)

        let incompleteSequenceParser = F.any().then(a()).then(F.any()) // Parses 'X', then 'a', then 'b'
        let incompleteParsing = incompleteSequenceParser.parse(stream)
        expect(incompleteParsing.isAccepted()).toBe(true) // parses Xab from 'Xabx' input
        expect(incompleteParsing.offset).toBe(3) // Offset should be 3 after Xab
    })
})



================================================
FILE: ingest/examples/flow/startWith-moveUntil-dropTo.spec.ts
================================================
import { Stream, F, C } from '@masala/parser'
import { describe, it, expect } from 'vitest'

const string = 'The quick brown fox jumps over the lazy dog'

describe('Flow Combinators (startWith, moveUntil, dropTo)', () => {
    it('should manipulate the stream and build a string', () => {
        const inputString = 'The quick brown fox jumps over the lazy dog'

        function combinator() {
            return F.startWith('hello: ')
                .then(F.moveUntil('brown'))
                .then(C.string('brown'))
                .then(F.dropTo('dog'))
        }

        let stream = Stream.ofChars(inputString)
        let parsing = combinator().parse(stream)

        expect(parsing.isAccepted()).toBe(true)
        expect(parsing.value.join('')).toBe('hello: The quick brown')
        expect(parsing.offset).toBe(inputString.length)
    })
})



================================================
FILE: ingest/examples/flow/try-with-no-or.spec.ts
================================================
import { Stream, F, C } from '@masala/parser'
import { describe, it, expect } from 'vitest'

describe('Flow Combinators (try, opt)', () => {
    it('should handle backtracking with try and optional parsing', () => {
        function day() {
            return C.stringIn([
                'MONDAY',
                'TUESDAY',
                'WEDNESDAY',
                'THURSDAY',
                'FRIDAY',
                'SATURDAY',
                'SUNDAY',
            ])
        }

        function blank() {
            return C.char(' ').rep().returns(' ') // returns a single space regardless of how many matched
        }

        const separator = () => C.string('---')

        // Tries to parse 'xyz', backtracks if fails
        function emptyTry() {
            return F.try(C.string('xyz')).debug('goback')
        }

        // Parses optional 'xyz'
        function optAlternative() {
            return C.string('xyz').opt()
        }

        function combinator() {
            return (
                day()
                    //.debug('day') // Parses TUESDAY
                    .then(blank().rep()) // Parses spaces

                    .then(separator()) // Parses '---'
                    .then(optAlternative().map((x) => x.orElse('42')))
                    //.debug('afterOPt') // Parses optional 'xyz', fails, returns '12'
                    .then(emptyTry().or(day()))
            ) // Tries 'xyz', fails, backtracks (consumes nothing)
        }

        const inputString = 'TUESDAY      ---FRIDAY' // Simplified input for clarity
        // Original: 'TUESDAY      THURSDAY  TUESDAY  ---FRIDAY'; causes issues with rep()

        let stream = Stream.ofChars(inputString)
        let parsing = combinator().parse(stream)

        // Based on the original assertFalse(parsing.isAccepted());
        // The final day() tries to parse FRIDAY after emptyTry failed and backtracked.
        // emptyTry failed at offset after '---' (index 15 in simplified string).
        // The final day() starts at offset 15 and parses FRIDAY.
        expect(parsing.isAccepted()).toBe(true) // Should be accepted if it parses TUESDAY --- [12] FRIDAY
        expect(parsing.value.array()).toEqual([
            'TUESDAY',
            ' ',
            '---',
            '42',
            'FRIDAY',
        ])
        expect(parsing.offset).toBe(inputString.length)

        // Let's test the original failure case logic - why did it fail?
        const originalString = 'TUESDAY      THURSDAY  TUESDAY  ---FRIDAY'
        let originalStream = Stream.ofChars(originalString)
        let originalParsing = combinator().parse(originalStream)
        // Perhaps the blank().rep() was too greedy?
        expect(originalParsing.isAccepted()).toBe(false) // Confirming original behavior
    })
})



================================================
FILE: ingest/examples/lazy/transmission.spec.ts
================================================
import { describe, it, expect } from 'vitest'
import { Stream, F, C, SingleParser, Tuple } from '@masala/parser'

describe('Lazy Combinator with Recursion', () => {
    it('should handle recursive parsing with F.lazy', () => {
        /**
         * A gives its VALUE to B using flatMap
         */
        function A(char: string): SingleParser<string> {
            // Parses repetition of char.toUpperCase(), then calls B
            return C.char(char.toUpperCase()).rep().flatMap(B)
        }

        /**
         * B tries to parse 'B', or lazily calls A
         * There is recursion, and we call A with lazy. We send PARAMETERS to A
         * within an array
         */
        function B(aVal: Tuple<string>): SingleParser<string> {
            // Parses 'B', maps result to include joined aVal
            const parseB = C.char('B').map((bVal) => aVal.join('') + '-' + bVal)
            // Lazily calls A with 'a' if parseB fails
            const recursiveA = F.lazy(A, ['a'])
            return parseB.or(recursiveA)
        }

        // Start the parser with A('a')
        const parser = A('a')

        // Input: AAA B
        const str = 'AAAB'
        const stream = Stream.ofChars(str)
        const parsing = parser.parse(stream)

        // A('a') -> C.char('A').rep() parses 'AAA'
        // flatMap(B) is called with aVal = ['A', 'A', 'A']
        // B(['A','A','A']) tries C.char('B').map(...)
        // Parses 'B', map returns 'AAA-B'
        expect(parsing.isAccepted()).toBe(true)
        expect(parsing.value).toBe('AAA-B') // Check the final assembled value
        expect(parsing.offset).toBe(str.length)
        expect(parsing.isEos()).toBe(true)
    })
})



================================================
FILE: ingest/examples/markdown/lib/bullet-parser.ts
================================================
/**
 * Created by Nicolas Zozol on 10/05/2019.
 */

import { F, C, SingleParser, TupleParser } from '@masala/parser'
import { formattedLine } from './text-parser.js'

import { blank, eol, spacesBlock } from './token.js'
import { BulletBlock, BulletLevel1, BulletLevel2 } from './types.js'

function stop() {
    return F.eos().or(C.charIn('\r\n*`'))
}

function pureText() {
    return F.not(stop())
        .rep()
        .map((chars) => chars.join(''))
}

function bulletLv1(): SingleParser<BulletLevel1> {
    return C.charIn('*-') //first character of a bullet is  * or -
        .then(blank()) // second character of a bullet is space or non-breakable space
        .then(formattedLine())
        .last()
        .map((someText) => ({
            type: 'bullet',
            level: 1,
            content: someText,
            children: [],
        }))
}

function bulletLv2(): SingleParser<BulletLevel2> {
    return spacesBlock(2)
        .then(blank().opt())
        .then(C.charIn('*-')) //first character of a bullet is  * or -
        .then(blank()) // second character of a bullet is space or non-breakable space
        .then(formattedLine())
        .last()
        .map((someText) => ({ type: 'bullet', level: 2, content: someText }))
}

export function bulletBlock(): SingleParser<BulletBlock> {
    const level2 = bulletLv2()
        .then(F.try(eol().drop().then(bulletLv2())).optrep())
        .array() as SingleParser<BulletLevel2[]>

    const level1 = bulletLv1() // father
        .then(
            F.try(eol().drop().then(level2))
                .opt()
                .map((o) => (o.isPresent() ? o.get() : [])),
        )
        .array()
        .map(([father, children]) => {
            return { ...father, children }
        }) as SingleParser<BulletLevel1>

    // this works:
    // const parser= bulletLv1().then(F.try(eol().drop().then(bulletLv1())).optrep());

    const parser = level1.then(
        F.try(eol().drop().then(level1)).optrep(),
    ) as TupleParser<BulletLevel1>

    return parser.array().map((bullets) => ({
        type: 'bulletBlock',
        bullets,
    }))
}

export function bullet() {
    return F.try(bulletLv2()).or(bulletLv1())
}



================================================
FILE: ingest/examples/markdown/lib/code-line-parser.ts
================================================
/**
 * Created by Simon on 03/01/2017.
 */

import { C, F, GenLex, SingleParser } from '@masala/parser'
import { eol, spacesBlock } from './token.js'
import { CodeBlock, CodeLine } from './types.js'

/* TODO mix spaces &  tab bug  "  \t  " will not be accepted
 known issue: non-breakable spaces are not recognised
  */
export function codeLine(spaces = 2) {
    return spacesBlock(spaces)
        .drop()
        .then(F.not(eol()).rep())
        .array()
        .map((s: string[]) => s.join('').trim())
        .map((text) => ({ type: 'codeLine', content: text }))
}

export function codeBlock(spaces = 2): SingleParser<CodeBlock> {
    let parser = codeLine(spaces)
        .then(F.try(eol().drop().then(codeLine()).single().optrep().array()))
        .array()
        .map(([firstLine, otherLines]) => {
            let lines = (otherLines as CodeLine[]).reduce(
                function (acc, line) {
                    return acc.concat(line)
                },
                [firstLine],
            ) as CodeLine[]

            return {
                type: 'codeBlock',
                lines: lines
                    .map((line) => line.content)
                    .filter((line) => line.length > 0),
            }
        })

    return parser
}



================================================
FILE: ingest/examples/markdown/lib/document-parser.ts
================================================
/**
 * Created by Simon on 16/12/2016.
 */

import { F, GenLex, TupleParser } from '@masala/parser'

import { paragraph } from './text-parser.js'
import { title } from './title-parser.js'
import { codeBlock } from './code-line-parser.js'
import { bullet, bulletBlock } from './bullet-parser.js'
import { eol, lineFeed } from './token.js'
import { MdElement } from './types.js'

export function markdown(): TupleParser<MdElement> {
    let genlex = new GenLex()
    const separator = eol().then(eol().rep())
    genlex.setSeparatorsParser(eol().then(eol().rep()))
    const tkBullets = genlex.tokenize(bulletBlock(), 'bulletBlock', 500)
    const tkCode = genlex.tokenize(codeBlock(2), 'codeBlock', 600)
    const tkText = genlex.tokenize(paragraph(), 'paragraph', 800)
    const tkTitle = genlex.tokenize(title(), 'title', 50)

    const grammar = F.any()
        .map((t) => t.value)
        .rep()

    return genlex.use(grammar) as TupleParser<MdElement>
}



================================================
FILE: ingest/examples/markdown/lib/front-matter.ts
================================================
import { F, C, Stream, Tuple, TupleParser } from '@masala/parser'
import { SingleParser } from '@masala/parser'

interface FrontMatterLine {
    name: string
    value: string
}
export type FrontMatterParser = TupleParser<FrontMatterLine>

const leftText = F.regex(/[a-zA-Z_][a-zA-Z0-9_]*/)
const stopper = C.char(':')
const rightText = F.moveUntil(C.char('\n'))

function identifier(): SingleParser<string> {
    return F.regex(/[a-zA-Z_][a-zA-Z0-9_]*/)
}

/*
function stopper() {
    return C.char(':')
}*/

function endLiner() {
    return C.char('\n').or(F.eos())
}

function lineSeparator() {
    return C.char('\n')
}
/*
function leftText(): SingleParser<string> {
    return identifier().then(stopper()).first()
}

function rightText(): SingleParser<string> {
    return F.moveUntil(endLiner().drop(), true)
}*/

function frontMatterLine(): SingleParser<FrontMatterLine> {
    return leftText
        .then(stopper.drop())
        .then(rightText.opt())
        .array()
        .map(([name, value]: any[]) => ({
            name,
            value: value.orElse('').trim(),
        }))
}

export const frontMatterParser: FrontMatterParser = frontMatterLine()
    .then(lineSeparator().optrep().drop())
    .single()
    .rep()



================================================
FILE: ingest/examples/markdown/lib/text-parser.ts
================================================
/**
 * Created by Simon on 14/12/2016.
 */

/**
 * This parse a text paragraph
 * text can be "simple" text; bold, italic or a mix (sequence) of those
 * a paragraph ends with a blank line("\n\n" or "\n  \t  \n") or "end of stream" (F.eos())
 *
 * Another solution is to use Genlex with stops on spaces and \n, then to reduce the text tokens
 * in bigger text.
 */
import { F, C, SingleParser, IParser } from '@masala/parser'

import { FormattedSequence, MdText, Paragraph } from './types.js'
import { blank, eol, lineFeed } from './token.js'

//TODO: no good at all=> For simplicity, bold, italic and code cannot go across different lines
function stop() {
    return F.eos().or(eol()).or(C.charIn('*`'))
    // real case would accept linefeed() instead of eol(), then probably a back parser when last char is '\n'
}

function pureText() {
    return (
        F.not(stop())
            .rep()
            .map((chars) => chars.join(''))

            /*.map(chars => {
                let allChars = chars.join('');
                return allChars.replace(/\n/g, ' ').replace(/\r/g, '');
            })*/
            .map((text) => text.trim())
    )
}

function italic(): SingleParser<MdText> {
    return C.char('*')
        .drop()
        .then(pureText())
        .then(C.char('*').drop())
        .single()
        .map((s: string) => ({ type: 'italic', text: s }))
}

function bold(): SingleParser<MdText> {
    return C.string('**')
        .drop()
        .then(pureText())
        .then(C.string('**').drop())
        .single()
        .map((s: string) => ({ type: 'bold', text: s }))
}

function code(): SingleParser<MdText> {
    return C.char('`')
        .drop()
        .then(pureText())
        .then(C.char('`').drop())
        .single()
        .map((s: string) => ({ type: 'code', text: s }))
}

function text(): SingleParser<MdText> {
    return pureText().map((s) => ({ type: 'text', text: s }))
}

export function formattedLine(): SingleParser<MdText[]> {
    return bold().or(italic()).or(text()).or(code()).rep().array()
}
/**
 * @param pureTextParser :SingleParser<string>  defines if a text accept some chars or not
 * @param stopParser :IParser<any> defines if text stops at the end of line
 * @returns Parser
 */
export function formattedSequence(
    pureTextParser: SingleParser<string>,
    stopParser: IParser<any>,
): SingleParser<FormattedSequence> {
    return bold()
        .or(italic())
        .or(text())
        .or(code())
        .rep()
        .then(stopParser.drop()) // could reuse formattedLine
        .array()
}

// So last eaten character could be a '\n'
export function paragraph(): SingleParser<any> {
    return formattedLine()
        .then(
            F.try(eol().drop().then(formattedLine()).single().optrep().array()),
        )
        .array()
        .map(([firstLine, otherLines]) => {
            let result = firstLine as MdText[]
            otherLines.forEach(
                (line: MdText[]) => (result = result.concat(line)),
            )

            let a = [
                { type: 'text', text: '' },
                { type: 'italic', text: 'italic' },
                { type: 'text', text: 'text' },
                [
                    { type: 'bold', text: 'then bold' },
                    { type: 'text', text: '' },
                ],
            ]
            const content = result.filter((mdText) => mdText.text.length > 0)

            return { type: 'paragraph', content }
        })
}



================================================
FILE: ingest/examples/markdown/lib/title-parser.ts
================================================
/**
 * Created by Simon on 14/12/2016.
 */
/*
 * This module try parse a title. The folowing will be recognised as titles:
 * "#foo\n"  "##foo\n"  "foo\n==="  "foo\n---"  "##########     foo     \n"
 *
 * Limits and axiomes
 * A \n in the markdown source ends the parsing of a title.  #foo\nbar  -> {title:foo},{text:bar}
 */
import { F, C, SingleParser } from '@masala/parser'

import { MdTitle } from './types.js'
import { blank, eol } from './token.js'

let end = () => F.eos().or(eol())

function sharps() {
    return C.char('#')
        .rep()
        .map((string) => ({
            typeOption: 'sharp',
            level: string.array().length,
        }))
}

// a white is a sequence of at least one space, tab or non-breakable space
function white() {
    return C.charIn(' \t\u00A0')
}

function fat() {
    return C.string('===').then(C.char('=').optrep()).returns(1) // this mean a level 1 title
}

function thin() {
    return C.string('---').then(C.char('-').optrep()).returns(2) // this mean a level 2 title
}

function titleSharp(): SingleParser<MdTitle> {
    return (
        sharps()
            .then(white().drop())
            .then(F.moveUntil(end()))
            .array()
            //.debug('')
            .map(([title, text]) => ({
                type: 'title',
                typeOption: 'sharp',
                level: title.level,
                text,
            }))
    )
}

function titleLine(): SingleParser<MdTitle> {
    return F.moveUntil(eol())
        .then(eol().drop())
        .then(fat().or(thin()))
        .array()
        .map(([text, level]) => ({
            type: 'title',
            level,
            text,
            typeOption: 'line',
        }))
}

function title() {
    return titleSharp().or(titleLine())
}

export { titleLine, titleSharp, title }



================================================
FILE: ingest/examples/markdown/lib/token.ts
================================================
import { F, C, IParser } from '@masala/parser'

// resolve meanningles characters as an empty string
// also accept an empty string

export function white() {
    return C.charIn('\u00A0 \t')
}
export function blank() {
    return C.charIn('\u00A0 \t').rep().returns(' ')
}

export function eol() {
    return C.char('\n').or(C.string('\r\n'))
}

//A blank line in the code(that is at least 2 consecutive \n) is a single end of line (lineFeed) in the rendition
export function lineFeed() {
    return eol().then(blank().opt()).then(eol()).returns({
        type: 'linefeed',
    })
}

//accept 1 tab or x spaces. Space may be unbreakable
export function spacesBlock(spaces: number) {
    return C.char('\t').or(white().occurrence(spaces))
}



================================================
FILE: ingest/examples/markdown/lib/types.ts
================================================
export interface HasTypeOption<O> {
    typeOption: O
}

export interface MdElement {
    type: string
}

export interface MdText extends MdElement {
    text: string
}

export interface MdTitle extends MdElement, HasTypeOption<string> {
    level: number
    text: string
}

export type FormattedSequence = MdText[]

export interface Paragraph extends MdElement {
    content: FormattedSequence
}

export interface CodeLine extends MdElement {
    content: string
}

export interface CodeBlock extends MdElement {
    lines: string[]
}

export interface Bullet extends MdElement {
    level: number
    content: FormattedSequence
}

export interface BulletLevel2 extends Bullet {}

export interface BulletLevel1 extends Bullet {
    children: BulletLevel2[]
}

export interface BulletBlock extends MdElement {
    bullets: BulletLevel1[]
}



================================================
FILE: ingest/examples/markdown/test/bullet-test.ts
================================================
import {
    assertDeepEquals,
    assertEquals,
    assertFalse,
    assertTrue,
} from '../../../assert.js'
import { bullet, bulletBlock } from '../lib/bullet-parser.js'
import { F, GenLex, Stream } from '@masala/parser'
import { eol } from '../lib/token.js'

export const bulletsTests = {
    'test text normal': function () {
        const line = `This is not a bullet`
        let actual = bullet().val(line)
        assertEquals(
            actual,
            undefined,
            'Normal text should not be accepted as a bullet',
        )
    },

    'test normal bullet': function () {
        const line = `* This is a bullet`
        let actual = bullet().val(line)
        let expected = {
            type: 'bullet',
            level: 1,
            children: [],
            content: [{ type: 'text', text: 'This is a bullet' }],
        }
        assertDeepEquals(expected, actual, 'problem test:test normal bullet')
    },

    'test bullet level 2': function () {
        let line = '  * This is a lvl2 bullet'
        let actual = bullet().val(line)
        let expected = {
            type: 'bullet',
            level: 2,
            content: [{ type: 'text', text: 'This is a lvl2 bullet' }],
        }
        assertDeepEquals(expected, actual, 'problem test:test bullet Lvl2')

        line = '  - This is a lvl2 bullet'
        actual = bullet().val(line)

        assertDeepEquals(expected, actual, 'problem test:test bullet Lvl2')
    },

    'test bullet level 2 mix tab spaces': function () {
        const line = '\t  * This is another lvl2 bullet\n  '
        let actual = bullet().val(line)

        let expected = {
            type: 'bullet',
            level: 2,
            content: [{ type: 'text', text: 'This is another lvl2 bullet' }],
        }

        assertDeepEquals(expected, actual, 'problem test:test bullet Lvl2')
    },

    'test bullet et format': function () {
        const line =
            '* This is a bullet *with italic* and even **bold characters**\n  '
        let actual = bullet().val(line)
        let expected = {
            type: 'bullet',
            level: 1,
            children: [],
            content: [
                { type: 'text', text: 'This is a bullet' },
                { type: 'italic', text: 'with italic' },
                { type: 'text', text: 'and even' },
                { type: 'bold', text: 'bold characters' },
            ],
        }
        assertDeepEquals(expected, actual, 'problem test:test bullet et format')
    },

    'test eol is not eaten with simple bullet': function () {
        const text = `* This is a bullet`
        const line = text + '\n'

        let response = bullet().parse(Stream.ofChars(line))
        assertTrue(response.isAccepted())
        assertEquals(response.offset, text.length)
    },

    'test simple bullet block': function () {
        const block = `* This is first bullet
* This is another bullet`

        let response = bulletBlock().parse(Stream.ofChars(block))
        assertTrue(response.isAccepted())
        assertTrue(response.isEos())
    },

    'test multilevel bullet block': function () {
        const block = `* This is first bullet
  - This is a child
  - This is another child`

        const text = block + '\n'

        let response = bulletBlock().parse(Stream.ofChars(text))
        assertTrue(response.isAccepted())
        assertEquals(block.length, response.offset)
        assertFalse(response.isEos())

        let otherResponse = bulletBlock()
            .then(eol())
            .parse(Stream.ofChars(text))
        assertTrue(otherResponse.isAccepted())
        assertTrue(otherResponse.isEos())
    },

    'test complex bullet block': function () {
        const block = `* This is first bullet
* This is another bullet
  - with *a* child
  - and a **final point**
`

        let actual = bulletBlock().val(block)

        let expected = {
            type: 'bulletBlock',
            bullets: [
                {
                    type: 'bullet',
                    level: 1,
                    content: [{ type: 'text', text: 'This is first bullet' }],
                    children: [],
                },
                {
                    type: 'bullet',
                    level: 1,
                    content: [{ type: 'text', text: 'This is another bullet' }],
                    children: [
                        {
                            type: 'bullet',
                            level: 2,
                            content: [
                                { type: 'text', text: 'with' },
                                { type: 'italic', text: 'a' },
                                {
                                    type: 'text',
                                    text: 'child',
                                },
                            ],
                        },
                        {
                            type: 'bullet',
                            level: 2,
                            content: [
                                { type: 'text', text: 'and a' },
                                { type: 'bold', text: 'final point' },
                            ],
                        },
                    ],
                },
            ],
        }

        assertDeepEquals(expected, actual, 'problem with Bullet Block')
    },

    'test two blocks': function () {
        const block = `* The princess Leia was an important character
* Han Solo is a murderer
    - but cleared by technology
* Force is strong

* Luke Skywalker is strong`

        let genlex = new GenLex()
        genlex.setSeparatorsParser(eol().then(eol().rep()))
        const tkBullets = genlex.tokenize(bulletBlock(), 'bulletBlock', 500)

        const grammar = tkBullets.rep().array()

        let parser = genlex.use(grammar)

        let actual = parser.val(block)
        assertEquals(2, actual.length)
    },
}



================================================
FILE: ingest/examples/markdown/test/code-block-test.ts
================================================
import { assertDeepEquals, assertEquals, assertTrue } from '../../../assert.js'
import { codeBlock, codeLine } from '../lib/code-line-parser.js'

export const codeBlockTests = {
    'test simple code 1ine': function () {
        const line = `    This is a code block`
        let actual = codeLine().val(line)
        let expected = { type: 'codeLine', content: 'This is a code block' }
        assertDeepEquals(expected, actual, 'This is a gentle block code')
    },

    'test simple code bloc': function () {
        let line = `  This is a code block
    This is the second code block
    This is the third code block`
        let actual = codeBlock().val(line)
        let expected = {
            type: 'codeBlock',
            lines: [
                'This is a code block',
                'This is the second code block',
                'This is the third code block',
            ],
        }
        assertDeepEquals(expected, actual, 'This is a gentle block code')

        line = `    This is a code block
    This is the second code block
    This is the third code block
`
        actual = codeBlock().val(line)
        assertDeepEquals(expected, actual, 'This is a gentle block code')
    },

    'test text normal': function () {
        const line = `This is not a code`
        let actual = codeBlock().val(line)
        assertTrue(actual === undefined)
    },

    'test bullet': function () {
        const line = `\t\t* This is  a  level2 bullet`
        let actual = codeBlock().val(line)
        assertTrue(
            actual !== undefined,
            'bullets should be accepted as a code block when no priority is set',
        )
    },

    'code blocks are not trimmed in this project': function () {
        const line = `\t\t  This is a code block`
        let actual = codeBlock().val(line)
        let expected = { type: 'codeBlock', lines: ['This is a code block'] }
        assertDeepEquals(
            expected,
            actual,
            '  This is a NOT TRIMMED block code starting with mixed tabs and spaces',
        )
    },

    'test code empty block': function () {
        const line = `\t`
        let actual = codeBlock().val(line)
        assertTrue(actual === undefined, 'Too empty for code block')
    },

    'test code space block': function () {
        const line = `\t  `
        let actual = codeBlock().val(line)
        let expected = { type: 'codeBlock', lines: [] }
        assertDeepEquals(
            expected,
            actual,
            '  This is a code line with only 2 spaces',
        )
    },
}



================================================
FILE: ingest/examples/markdown/test/document-test.ts
================================================
import { markdown } from '../lib/document-parser.js'
import { assertEquals, assertTrue } from '../../../assert.js'

const document = `

# Star Wars rocks

This is a nice trilogy

Star Trek rocks also
=====

But more because of the extended universe and games around. *Star Wars* games are less regular.

Good to know
---

* The princess Leia was an important character
* Han Solo is a murderer
    - but it was cleared by technology
* Luke Skywalker is strong     

  a bit of code
    here and there

All these characters were very popular. *Jar Jar Bin* is not.

`

export const documentTests = {
    'test document': function () {
        const actual = markdown().val(document)

        assertEquals(
            1,
            actual.array().filter((md) => md.type === 'bulletBlock').length,
        )
        assertEquals(
            1,
            actual.array().filter((md) => md.type === 'codeBlock').length,
        )
        assertEquals(
            3,
            actual.array().filter((md) => md.type === 'title').length,
        )
        assertEquals(
            3,
            actual.array().filter((md) => md.type === 'paragraph').length,
        )
    },
}



================================================
FILE: ingest/examples/markdown/test/front-matter.spec.ts
================================================
import { describe, it, expect } from 'vitest'
import { frontMatterParser } from '../lib/front-matter.js'
import { Stream } from '@masala/parser'

describe('Front Matter Parser', () => {
    it('should parse a single line of front matter', () => {
        const input = Stream.ofChars('title: My Document\n')
        const result = frontMatterParser.parse(input)
        expect(result.isAccepted()).toBe(true)
        expect(result.value.array()).toEqual([
            { name: 'title', value: 'My Document' },
        ])
    })

    it('should parse multiple lines of front matter', () => {
        const input = Stream.ofChars(`title: My Document
author: John Doe
date: 2024-03-20
`)
        const result = frontMatterParser.parse(input)
        expect(result.isAccepted()).toBe(true)
        expect(result.value.array()).toEqual([
            { name: 'title', value: 'My Document' },
            { name: 'author', value: 'John Doe' },
            { name: 'date', value: '2024-03-20' },
        ])
    })

    it('should handle empty values', () => {
        const input = Stream.ofChars('title:\n')
        const result = frontMatterParser.parse(input)
        expect(result.isAccepted()).toBe(true)
        expect(result.value.array()).toEqual([{ name: 'title', value: '' }])
    })

    it('should reject invalid identifiers', () => {
        const input = Stream.ofChars('123title: Invalid\n')
        const result = frontMatterParser.parse(input)
        expect(result.isAccepted()).toBe(false)
    })

    it('should handle multiple newlines between entries', () => {
        const input = Stream.ofChars(`title: My Document

author: John Doe

date: 2024-03-20
`)
        const result = frontMatterParser.parse(input)
        expect(result.isAccepted()).toBe(true)
        expect(result.value.array()).toEqual([
            { name: 'title', value: 'My Document' },
            { name: 'author', value: 'John Doe' },
            { name: 'date', value: '2024-03-20' },
        ])
    })
})



================================================
FILE: ingest/examples/markdown/test/markdown-test.ts
================================================
import { launch } from '../../../assert.js'
import { textTests } from './text-test.js'
import { titleTests } from './title-test.js'
import { codeBlockTests } from './code-block-test.js'
import { bulletsTests } from './bullet-test.js'
import { documentTests } from './document-test.js'

export function launchMarkdown(): void {
    launch(codeBlockTests)
    launch(textTests)
    launch(titleTests)
    launch(bulletsTests)
    launch(documentTests)
}

launchMarkdown()



================================================
FILE: ingest/examples/markdown/test/text-test.ts
================================================
import { assertDeepEquals, assertEquals, assertTrue } from '../../../assert.js'
import { paragraph } from '../lib/text-parser.js'
import { Stream } from '@masala/parser'

export const textTests = {
    'test empty text': function () {
        let actual = paragraph().val('')

        assertTrue(actual === undefined, 'blank text refused')

        actual = paragraph().val('   ')
        let expected = { type: 'paragraph', content: [] }
        assertDeepEquals(expected, actual, 'blank line are filtered')
    },

    'test simple text': function () {
        let actual = paragraph().val('text')
        let expected = {
            type: 'paragraph',
            content: [{ type: 'text', text: 'text' }],
        }
        assertDeepEquals(expected, actual)

        actual = paragraph().val('  text ')
        assertDeepEquals(actual, expected)
    },

    'test italic': function () {
        let actual = paragraph().val('*text*')
        let expected = {
            type: 'paragraph',
            content: [{ type: 'italic', text: 'text' }],
        }
        assertDeepEquals(actual, expected)
    },

    'test bold': function () {
        let actual = paragraph().val('**text**')
        let expected = {
            type: 'paragraph',
            content: [{ type: 'bold', text: 'text' }],
        }
        assertDeepEquals(actual, expected)
    },

    'test combined format': function () {
        let actual = paragraph().val('  *italic* text **then bold** ')
        let expected = {
            type: 'paragraph',
            content: [
                { type: 'italic', text: 'italic' },
                { type: 'text', text: 'text' },
                { type: 'bold', text: 'then bold' },
            ],
        }

        assertDeepEquals(actual, expected)
    },

    'single \\n must be translated as space': function () {
        let actual = paragraph().val(
            '  *italic* text\n**then bold**\nthen *final italic text* ',
        )
        let expected = {
            type: 'paragraph',
            content: [
                { type: 'italic', text: 'italic' },
                { type: 'text', text: 'text' },
                {
                    type: 'bold',
                    text: 'then bold',
                },
                { type: 'text', text: 'then' },
                { type: 'italic', text: 'final italic text' },
            ],
        }

        assertDeepEquals(actual, expected)
    },

    'other complex paragraph': function () {
        const complexParagraph = `They know how to  *use the force*
  , speed up,  and destroy **Death Stars**.`
        let text = complexParagraph + '\n'

        const expectedComplexParagraph = {
            type: 'paragraph',
            content: [
                { type: 'text', text: 'They know how to' },
                { type: 'italic', text: 'use the force' },
                { type: 'text', text: ', speed up,  and destroy' },
                { type: 'bold', text: 'Death Stars' },
                { type: 'text', text: '.' },
            ],
        }
        let response = paragraph().parse(Stream.ofChars(text))

        assertDeepEquals(response.value, expectedComplexParagraph)
        assertEquals(response.offset, complexParagraph.length)
    },
}



================================================
FILE: ingest/examples/markdown/test/title-test.ts
================================================
/**
 * Created by Nicolas Zozol on 14/12/2016.
 */
import { title } from '../lib/title-parser.js'
import { assertDeepEquals, assertEquals, assertTrue } from '../../../assert.js'
import { bullet } from '../lib/bullet-parser.js'
import { Stream } from '@masala/parser'

export const titleTests = {
    'test level1': function () {
        let actual = title().val('# title1\n')
        let expected = {
            level: 1,
            text: 'title1',
            type: 'title',
            typeOption: 'sharp',
        }
        assertDeepEquals(actual, expected)
    },

    'test level3': function () {
        let actual = title().val('### title\n')
        let expected = {
            level: 3,
            text: 'title',
            type: 'title',
            typeOption: 'sharp',
        }
        assertDeepEquals(expected, actual, 'test title level 3')
    },

    'title alternate 1 should be accepted': function () {
        let actual = title().val('Title\n=====\n')
        let expected = {
            level: 1,
            text: 'Title',
            type: 'title',
            typeOption: 'line',
        }

        assertDeepEquals(expected, actual, 'test title1 alt')
    },

    'title alternate 1 should be title1': function () {
        let actual = title().val('Title\n=====   \n')
        let expected = {
            type: 'title',
            typeOption: 'line',
            level: 1,
            text: 'Title',
        }

        assertDeepEquals(expected, actual, 'test title1 alt')
    },

    'title alternate 2 should be accepted': function () {
        let actual = title().val('Title\n-----\n')
        let expected = {
            type: 'title',
            typeOption: 'line',
            level: 2,
            text: 'Title',
        }

        assertDeepEquals(expected, actual, 'test title2 alt')
    },

    'title alternate 2 should be title1': function () {
        let actual = title().val('Title\n------   \n')
        let expected = {
            type: 'title',
            typeOption: 'line',
            level: 2,
            text: 'Title',
        }

        assertDeepEquals(expected, actual, 'test title2 alt')
    },

    ' stars into title': function () {
        let actual = title().val('2*3*4 = 24\n------   \n')
        let expected = {
            type: 'title',
            typeOption: 'line',
            level: 2,
            text: '2*3*4 = 24',
        }

        assertDeepEquals(expected, actual, 'test stars in title1')

        actual = title().val('## 2*3*4 = 24\n')
        expected = {
            type: 'title',
            typeOption: 'sharp',
            level: 2,
            text: '2*3*4 = 24',
        }

        assertDeepEquals(expected, actual, 'test stars in title2')
    },

    'Sharps not followed by space': function () {
        let actual = title().val('#Not tile')

        assertEquals(
            actual,
            undefined,
            'Sharp not followed by space shall not be parsed',
        )
    },

    'Sharp title does not eat eol': function () {
        const text = `### This is a title`
        const line = text + '\n'

        let response = title().parse(Stream.ofChars(line))
        assertTrue(response.isAccepted())
        assertEquals(response.offset, text.length)
    },

    'Line title does not eat eol': function () {
        const text = `This is a title\n------`
        const line = text + '\n'

        let response = title().parse(Stream.ofChars(line))
        assertTrue(response.isAccepted())
        assertEquals(response.offset, text.length)
    },
}



================================================
FILE: ingest/examples/markdown/test/samples/paragraph-expected.json
================================================
[
  {
    "title": {
      "level": 1,
      "text": "title1"
    }
  },
  {
    "paragraph":[{
      "text":"This is a paragraph"
    }]
  },
  {
    "paragraph":[{
      "text":"This is another paragraph"
    }]
  }
]


================================================
FILE: ingest/examples/markdown/test/samples/paragraph-test.md
================================================
title1
====

This is a paragraph

This is another paragraph



================================================
FILE: ingest/examples/markdown/test/samples/trivial-expected.json
================================================
[
  {
    "title": {
      "level": 1,
      "text": "title1"
    }
  }
]


================================================
FILE: ingest/examples/markdown/test/samples/trivial-test.md
================================================
title1
====



================================================
FILE: ingest/examples/operations/plus-minus.spec.ts
================================================
import { Stream, F, C, SingleParser, Option, Tuple } from '@masala/parser'
import { describe, it, expect } from 'vitest'

/*
 Implementing general solution :
 E -> T E'
 E' -> + TE'  |  eps
 T -> F T'
 T' -> * FT'  |  eps
 F -> DAY | ( E )

 E== expr
 T == subExpr
 E'== optPlusExpr
 T' == optMultExpr
 F == terminal

 expr -> subExpr optPlusExpr'
 optPlusExpr -> ( + then subExpr then F.lazy(optPlusExpr) ).opt()
 subExpr -> terminal then optMultExpr
 optMultExpr -> ( * then terminal then F.lazy(optMultExpr) ).opt()
 F -> F.try( '(' then expr then ')' ).or(N.litteral)

 */

const MULT = 'MULT'
const PLUS = 'PLUS'

function text() {
    return F.not(anyOperation().or(C.charIn('()')))
        .rep()
        .map((v) => parseInt(v.join('').trim()))
}

function blank() {
    return C.char(' ').rep().returns(' ')
}

function anyOperation() {
    return C.string('*').returns(MULT).or(C.string('+').returns(PLUS))
}

function andOperation() {
    return C.string('*').returns(MULT)
}

function plusOperation() {
    return C.string('+').returns(PLUS)
}

function parenthesis(par: string) {
    return C.char(' ').optrep().drop().then(C.char(par))
}

function parenthesisExpr(): SingleParser<number> {
    return parenthesis('(')
        .then(blank().opt())
        .drop()
        .then(F.lazy(expr))
        .then(parenthesis(')').then(blank().opt()).drop())
        .single()
}

function expr(): SingleParser<number> {
    const parser = subExpr().then(optionalPlusExpr()).array() as SingleParser<
        [number, Option<number>]
    >
    return parser.map(([left, right]) => left + right.orElse(0))
}

function optionalPlusExpr(): SingleParser<Option<number>> {
    return plusExpr().opt()
}

function plusExpr() {
    const parser = plusOperation()
        .drop()
        .then(subExpr())
        .then(F.lazy(optionalPlusExpr))
        .array() as SingleParser<[number, Option<number>]>
    return parser.map(([left, right]) => left + right.orElse(0))
}

function subExpr() {
    const parser = terminal().then(optionalMultExpr()).array() as SingleParser<
        [number, Option<number>]
    >
    return parser.map(([left, right]) => left * right.orElse(1))
}

function optionalMultExpr(): SingleParser<Option<number>> {
    return multExpr().opt()
}

function multExpr() {
    const parser = andOperation()
        .drop()
        .then(terminal())
        .then(F.lazy(optionalMultExpr))
        .array() as SingleParser<[number, Option<number>]>
    return parser.map(([left, right]) => left * right.orElse(1))
}

function terminal() {
    return F.try(parenthesisExpr()).or(text())
}

function combinator() {
    return expr().eos()
}

describe('Expression Parser (+, *)', () => {
    // Helper function to run the parser and return the result value or throw error
    const parseExpr = (input: string): number => {
        let stream = Stream.ofChars(input)
        let response = combinator().parse(stream)
        if (response.isAccepted() && response.isEos()) {
            return response.value
        } else {
            // Provide more info on failure
            throw new Error(
                `Parsing failed for input: "${input}". Accepted: ${response.isAccepted()}, EOS: ${response.isEos()}, Offset: ${
                    response.offset
                }`,
            )
        }
    }

    it('should handle simple addition', () => {
        expect(parseExpr('2 + 3')).toBe(5)
    })

    it('should handle negative number (sic!)', () => {
        expect(parseExpr('2+  -3')).toBe(-1)
    })

    it('should handle simple multiplication', () => {
        expect(parseExpr('4 * 5')).toBe(20)
    })

    it('should respect multiplication priority', () => {
        expect(parseExpr('2 + 3 * 4')).toBe(14) // 3 * 4 = 12, 2 + 12 = 14
    })

    it('should respect addition priority with parentheses', () => {
        expect(parseExpr('(2 + 3) * 4')).toBe(20) // 2 + 3 = 5, 5 * 4 = 20
    })

    it('should handle nested parentheses', () => {
        expect(parseExpr('2 * (3 + (4 * 5))')).toBe(46) // 4*5=20, 3+20=23, 2*23=46
    })

    it('should handle spaces correctly', () => {
        expect(parseExpr(' 10 +   5  *  2 ')).toBe(20)
    })

    it('should parse the original complex expression', () => {
        const originalString = '2 + 3 * (  (   4  +   10) + ( 4) ) + 1' // Simplified: removed * -3 for now
        expect(parseExpr(originalString)).toBe(57) // 4+10=14, 14+4=18, 3*18=54, 2+54=56, 56+1=57 -> Let's re-evaluate calculation
        // 4 + 10 = 14
        // (14) + (4) = 18
        // 3 * 18 = 54
        // 2 + 54 = 56
        // 56 + 1 = 57
        expect(parseExpr(originalString)).toBe(57)
    })

    // TODO: Add test case for negative numbers if the parser is intended to support them.
    // The original example had '... * -3', but the 'text' parser likely only handles positive integers.
    // it('should handle the original expression with negative number', () => {
    //     const stringWithNegative = '2 + 3 * (  (   4  +   10) + ( 4) ) + 1 * -3';
    //     expect(parseExpr(stringWithNegative)).toBe(53); // 57 + (1 * -3) = 57 - 3 = 54? Let's re-calc original expected 53.
    // 57 + 1*(-3) => 57-3 = 54. Original assertEquals(53, response.value) seems off unless priority is different.
    // });
})



================================================
FILE: ingest/examples/opt-and-rep/forever-parse.spec.ts
================================================
import { describe, it, expect } from 'vitest'
import { Worker } from 'node:worker_threads'

/**
 * Nested .optrep() is known to loop forever.  We detect that by
 * running the parse in a worker-thread and terminating it after
 * 300 ms.  The test EXPECTS that termination (i.e. the promise
 * rejects with “timeout”); if the parser ever returns normally
 * the assertion will fail – which is exactly what we want once
 * the bug is fixed.
 */
describe('should parse optrep().optrep() forever, but we stop it', () => {
    it('should throw after 0.3 s when nested optrep() hangs', async () => {
        const worker = new Worker(
            new URL('./forever-parse.worker.mjs', import.meta.url),
            // { type: 'module' }
        )

        const parsePromise = new Promise((_, reject) => {
            const timer = setTimeout(() => {
                worker.terminate().then(() => reject(new Error('timeout')))
            }, 200)

            worker.once('message', (msg) => {
                clearTimeout(timer)
                reject(
                    new Error(
                        typeof msg === 'string'
                            ? `unexpected worker completion: ${msg}`
                            : `worker error: ${msg.error}`,
                    ),
                )
            })

            worker.once('error', (err) => {
                clearTimeout(timer)
                reject(err)
            })
        })

        await expect(parsePromise).rejects.toThrow('timeout')
    }, 1_000)
})



================================================
FILE: ingest/examples/opt-and-rep/forever-parse.worker.mjs
================================================
import { parentPort } from 'node:worker_threads'
import { C, N, Stream } from '@masala/parser'

const blocks = N.number().then(C.char('/')).optrep().optrep() // the forever parse

try {
    const stream = Stream.ofChars('1/2/3/4/5/')
    blocks.parse(stream)
    parentPort.postMessage('finished') // should never happen
} catch (e) {
    parentPort.postMessage({ error: e?.message ?? String(e) })
}



================================================
FILE: ingest/examples/opt-and-rep/opt.spec.ts
================================================
import { C, N, Tuple, Stream } from '@masala/parser'
import { describe, it, expect } from 'vitest'

describe('Optional parser', () => {
    it('should create an option', () => {
        const c = C.char('a').opt()
        const n = N.number()

        const mixed = c.then(n)

        const data = mixed.val('a0') as Tuple<any>
        expect(data.size()).toEqual(2)
    })

    it('should create a resolved option ', () => {
        const c = C.char('a')
            .opt()
            .map((v) => {
                return v.orElse('b')
            })
        const n = C.char('z')

        const mixed = c.then(n)
        const stream = Stream.ofChars('zNOT_REACHED')

        const response = mixed.parse(stream) // not 'a', so we have 'b' as default value
        const data = response.value
        expect(data.size()).toEqual(2)
        expect(data.at(0)).toEqual('b')
        expect(response.offset).toEqual(1)
    })

    it('should merge tuple options nicely', () => {
        const tupleParser = C.char('a').then(C.char('b')).opt()
        const stringParser = C.string('!!!')

        const mixed = tupleParser.then(stringParser)

        // First case: the tuple is not here
        const data = mixed.val('!!!')
        const first = data.first()
        const last = data.last()
        expect(first.isPresent()).toBeFalsy()
        expect(last).toBe('!!!')
    })

    it('should merge void nicely', () => {
        const tupleParser = C.char('a').then(C.char('b')).drop().opt()
        const stringParser = C.string('!!!')

        const mixed = tupleParser.then(stringParser)

        // First case: the tuple is not here
        const data = mixed.val('ab!!!')
        const first = data.first()
        const last = data.last()
        expect(first.isPresent()).toBeTruthy()
        expect(last).toBe('!!!')
    })
})



================================================
FILE: ingest/examples/opt-and-rep/optrep.spec.ts
================================================
import { C, N, Stream } from '@masala/parser'
import { describe, it, expect } from 'vitest'
import { Worker } from 'worker_threads'

describe('Optrep parser', () => {
    describe('optrep parser', () => {
        it('should accept *zero* occurrence and still proceed', () => {
            const tp = C.char('a').optrep() // ← 0‒∞ “a”
            const mixed = tp.then(N.number()) // tuple + trailing number

            const data = mixed.val('0') // no “a”, just the number
            expect(data.size()).toEqual(1)
            expect(data.first()).toBe(0)
        })

        it('should collect many occurrences just like rep() but stay optional', () => {
            const tp = C.char('a').optrep()
            const mixed = tp.then(N.number())

            const data = mixed.val('aaa0')
            expect(data.size()).toEqual(4) // 3 × 'a'  +  1 number
            expect(data.at(0)).toBe('a')
            expect(data.at(2)).toBe('a')
            expect(data.last()).toBe(0)
        })

        it('should merge neutral elements cleanly when dropped', () => {
            const spaces = C.char(' ').drop().optrep() // skip leading blanks
            const word = C.letters()

            const mixed = spaces.then(word)

            const data = mixed.val('   hello')
            expect(data.size()).toEqual(1) // blanks vanished
            expect(data.first()).toBe('hello')
        })

        it('should build structured results out of zero-or-more tokens', () => {
            type Token = { word: string; punctuation?: string }

            const punct = C.charIn('.,!?').opt() // optional punctuation
            const token = C.letters()
                .then(punct)
                .array() // collect all tokens
                .map(
                    ([word, p]) =>
                        ({ word, punctuation: p.orElse(undefined) }) as Token,
                )

            const sentence = token.optrep() // 0‒∞ tokens

            const data = sentence.val('hello,world!')
            expect(data.size()).toEqual(2) // h e l l o ,  w o r l d !
            expect(data.at(0).word).toBe('hello')
            expect(data.at(0).punctuation).toBe(',')
            expect(data.last().punctuation).toBe('!')
        })
    })
})



================================================
FILE: ingest/examples/opt-and-rep/rep.spec.ts
================================================
import { C, N, Stream } from '@masala/parser'
import { describe, it, expect } from 'vitest'

describe('rep parser', () => {
    it('should create a tuple', () => {
        const tp = C.char('a').rep()
        const n = N.number()
        const mixed = tp.then(n)

        const data = mixed.val('aaa0')
        const last = data.last()
        expect(data.size()).toEqual(4)
        expect(data.at(0)).toEqual('a')
        expect(data.at(3)).toEqual(0)
        expect(last).toEqual(0)
    })
    it('should create support emptyTupleParser', () => {
        const tp = C.char('a').drop().rep()
        const n = N.number()
        const parser = tp.then(n)

        const data = parser.val('aaa100')
        expect(data.first()).toBe(100)
    })

    it('should create support TupleParser', () => {
        const n = N.number().then(C.char('/')).rep()

        const string = '1/2/3/4/5/'
        const stream = Stream.ofChars(string)
        const response = n.parse(stream)
        const data = response.value

        expect(response.isAccepted()).toBeTruthy()
        expect(data.size()).toEqual(string.length)
    })

    it('rep support structure', () => {
        type Struct = {
            value: number
            separator: string
        }
        const separator = C.charIn('#/')
        const n = N.number()
            .then(separator)
            .array()
            .map(([value, separator]) => ({ value, separator }) as Struct)
            .rep()

        const string = '1#2#3/4/5/'
        const stream = Stream.ofChars(string)
        const response = n.parse(stream)
        const data = response.value

        expect(response.isAccepted()).toBeTruthy()
        expect(data.size()).toEqual(string.length / 2)
        expect(data.at(0).value).toEqual(1)
        expect(data.at(0).separator).toEqual('#')
    })

    it('should rep rep', () => {
        const n = N.number().then(C.char('/')).rep().rep()

        const string = '1/2/3/4/5/'
        const stream = Stream.ofChars(string)
        const response = n.parse(stream)
        const data = response.value

        expect(response.isAccepted()).toBeTruthy()
        expect(data.size()).toEqual(string.length)
    })

    it('should rep singleParser cleanly', () => {
        const n = N.digit().rep()

        const string = '12345'
        const stream = Stream.ofChars(string)
        const response = n.parse(stream)
        const data = response.value

        expect(response.isAccepted()).toBeTruthy()
        expect(data.size()).toEqual(string.length)
    })
})



================================================
FILE: ingest/examples/tuple/tuple.spec.ts
================================================
import { tuple } from '@masala/parser'
import { describe, expect, it } from 'vitest'

describe('Tuple typescript integration', () => {
    it('should create mixed tuple that handle first and last object', () => {
        const empty = tuple()
        const nTuple = empty.append(2)
        const mixedTuple = nTuple.append('a')
        const first = mixedTuple.first()
        const last = mixedTuple.last()
        expect(first).toBe(2)
        expect(last).toBe('a')

        const stillMixedTuple = nTuple.append('a').append('b')
        expect(stillMixedTuple.last()).toBe('b')
    })

    it('should create a same Tuple with append', () => {
        const empty = tuple()
        const nTuple = empty.append(2)
        const bigger = nTuple.append(3).append(4)
        const first = bigger.first()
        const last = bigger.last()
        expect(first).toBe(2)
        expect(last).toBe(4)
    })

    it('merges tuples', () => {
        const tuple1 = tuple([1, 2, 3])
        const tuple2 = tuple([4, 5, 6])
        const merged = tuple1.append(tuple2)
        expect(merged.first()).toBe(1)
        expect(merged.last()).toBe(6)
        expect(merged.at(3)).toBe(4)
    })

    it('merges tuples still mixing', () => {
        const tuple1 = tuple([1, 2, 3])
        const tuple2 = tuple(['a', 'b', 'c'])
        const merged = tuple1.append(tuple2)
        expect(merged.first()).toBe(1)
        expect(merged.last()).toBe('c')
    })

    it('merges empty tuples correctly', () => {
        const tuple1 = tuple()
        const tuple2 = tuple()
        const merged = tuple1.append(tuple2)
        expect(merged.first()).toBe(undefined)
        expect(merged.last()).toBe(undefined)
        expect(merged.isEmpty()).toBe(true)
    })

    it('merges empty tuple with different types', () => {
        const tuple1 = tuple()
        const tuple2 = tuple([4, 5, 6])
        const merged = tuple1.append(tuple2)
        expect(merged.first()).toBe(4)
    })

    it('merges empty tuple with different types, other order', () => {
        const tuple1 = tuple([4, 5, 6])
        const tuple2 = tuple()
        const merged = tuple1.append(tuple2)
        expect(merged.first()).toBe(4)
    })

    it('merges mixed tuples correctly', () => {
        type T1 = 'T1'
        type T2 = 'T2'
        const t1: T1 = 'T1'
        const t2: T2 = 'T2'

        const tuple1 = tuple().append(1).append('b')
        const tuple2 = tuple().append(t1).append(t2)
        const merged = tuple1.append(tuple2)
        expect(merged.first()).toBe(1)
        expect(merged.last()).toBe('T2')
    })

    it('merges empty tuple with mixed tuple', () => {
        const tuple1 = tuple()
        const tuple2 = tuple().append(1).append('b')
        const merged = tuple1.append(tuple2)
        expect(merged.first()).toBe(1)
        expect(merged.last()).toBe('b')
    })

    it('merges mixed tuple with empty tuple, other side', () => {
        const tuple1 = tuple().append(1).append('b')
        const tuple2 = tuple()
        const merged = tuple1.append(tuple2)
        expect(merged.first()).toBe(1)
        expect(merged.last()).toBe('b')
    })
})



================================================
FILE: ingest/examples/tuple-parser/tuple-parser.spec.ts
================================================
import { C, N, F } from '@masala/parser'
import { describe, it, expect } from 'vitest'

describe('Tuple typescript integration', () => {
    it('should create mixed parser that handle first and last object', () => {
        const c = C.char('a')
        const n = N.number()
        const mixed = c.then(n)

        const first = mixed.first()
        const valueFirst = first.val('a0')
        expect(valueFirst).toBe('a')

        const last = mixed.last()
        const valueLast = last.val('a0')
        expect(valueLast).toBe(0)
    })

    it('should create a same parser with then', () => {
        const a = C.char('a')
        const b = C.char('b')
        const mixed = a.then(b).then(F.any().drop())

        const first = mixed.first()
        const valueFirst = first.val('ab0')
        expect(valueFirst).toBe('a')

        const last = mixed.last()
        const valueLast = last.val('ab0')
        expect(valueLast).toBe('b')
    })

    it('Appending from dropped, it should create a string parser with then', () => {
        const a = C.char('a')
        const stringsParser = F.any().drop().then(a)

        const first = stringsParser.first()
        const valueFirst = first.val('0ab')
        expect(valueFirst).toBe('a')
    })

    it('Appending from dropped, it should create a mixedParser with then', () => {
        const a = C.char('a')
        const b = N.number()
        const stringsParser = F.any().drop().then(a).then(b)

        const first = stringsParser.first()
        const valueFirst = first.val('Xa45')
        expect(valueFirst).toBe('a')

        const last = stringsParser.last()
        const valueLast = last.val('Xa45')
        expect(valueLast).toBe(45)
    })
})



================================================
FILE: ingest/test/data/option.spec.js
================================================
import { describe, it, expect } from 'vitest'
import option from '../../lib/data/option.js'

describe('Option Data Type Tests', () => {
    it('option empty', () => {
        expect(option.none().isPresent()).toBe(false)
    })

    it('option not empty', () => {
        expect(option.some(12).isPresent()).toBe(true)
    })

    it('option empty mapped', () => {
        expect(
            option
                .none()
                .map(function (a) {
                    return a
                })
                .isPresent(),
        ).toBe(false)
    })

    it('option not empty mapped', () => {
        expect(
            option
                .some(12)
                .map(function (a) {
                    return a
                })
                .get(),
        ).toBe(12)
    })

    it('option not empty flat mapped to option', () => {
        expect(
            option
                .some(12)
                .flatMap(function (a) {
                    return option.some(a)
                })
                .get(),
        ).toBe(12)
    })

    it('option empty flat mapped', () => {
        expect(
            option
                .none()
                .flatMap(function (a) {
                    return a // This function wouldn't be called for none()
                })
                .isPresent(),
        ).toBe(false)
    })

    it('option empty or else', () => {
        expect(option.none().orElse(12)).toBe(12)
    })

    it('option not empty or else', () => {
        expect(option.some(12).orElse(14)).toBe(12)
    })

    it('option empty or lazy else', () => {
        expect(
            option.none().orLazyElse(function () {
                return 12
            }),
        ).toBe(12)
    })

    it('option not empty or lazy else', () => {
        expect(
            option.some(12).orLazyElse(function () {
                return 14
            }),
        ).toBe(12)
    })

    it('option empty filter', () => {
        expect(
            option
                .none()
                .filter(function (v) {
                    return v === 1
                })
                .isPresent(),
        ).toBe(false)
    })

    it('option not empty filter', () => {
        expect(
            option
                .some(12)
                .filter(function (v) {
                    return v === 12
                })
                .get(),
        ).toBe(12)
    })

    it('option not empty wrong filter', () => {
        expect(
            option
                .some(12)
                .filter(function (v) {
                    return v === 13
                })
                .isPresent(),
        ).toBe(false)
    })
})



================================================
FILE: ingest/test/data/try.spec.js
================================================
import { describe, it, expect } from 'vitest'
import atry from '../../lib/data/try.js'

describe('Try Data Type Tests', () => {
    it('atry success', () => {
        expect(atry.success(1).isSuccess()).toBe(true)
    })

    it('atry failure', () => {
        expect(atry.failure(new Error('failure')).isFailure()).toBe(true)
    })

    it('atry success map can be a success', () => {
        expect(
            atry
                .success(1)
                .map((i) => i + 1)
                .isSuccess(),
        ).toBe(true)
    })

    it('atry success map can be a failure', () => {
        expect(
            atry
                .success(1)
                .map(() => {
                    throw new Error('test error')
                })
                .isFailure(),
        ).toBe(true)
    })

    it('atry success map', () => {
        expect(
            atry
                .success(1)
                .map((i) => i + 1)
                .success(),
        ).toBe(2)
    })

    it('atry failure map is a failure', () => {
        expect(
            atry
                .failure(new Error('failure'))
                .map((i) => i + 1) // This map function won't be executed
                .isFailure(),
        ).toBe(true)
    })

    it('atry failure map', () => {
        const failureValue = new Error('original failure')
        expect(
            atry
                .failure(failureValue)
                .map((i) => i + 1) // This map function won't be executed
                .failure(),
        ).toBe(failureValue)
    })

    it('atry success flatMap of atry', () => {
        expect(
            atry
                .success(1)
                .flatMap((i) => atry.success(i + 1))
                .success(),
        ).toBe(2)
    })

    it('atry failure flatMap of atry (original name: atry failure flatMap of int)', () => {
        const failureValue = new Error('original failure')
        expect(
            atry
                .failure(failureValue)
                .flatMap((i) => atry.success(i + 1)) // This function won't be executed
                .failure(),
        ).toBe(failureValue)
    })

    it('atry success flatMap that throws (original name: atry failure flatMap of Error)', () => {
        const errorThrown = new Error('flatMap error')
        const result = atry.success(1).flatMap(() => {
            throw errorThrown
        })
        expect(result.isFailure()).toBe(true)
        expect(result.failure()).toBe(errorThrown)
    })

    it('atry success recoverWith', () => {
        const result = atry.success(1).recoverWith(2)

        expect(result).toBe(1)
    })

    it('atry failure recoverWith', () => {
        expect(atry.failure(1).recoverWith(2)).toBe(2)
    })

    it('atry success lazyRecoverWith', () => {
        const result = atry.success(1).lazyRecoverWith(() => 2)
        expect(result).toBe(1)
    })

    it('atry failure lazyRecoverWith', () => {
        expect(
            atry.failure(new Error('failure')).lazyRecoverWith(() => 2),
        ).toBe(2)
    })

    it('atry success filter', () => {
        expect(
            atry
                .success(1)
                .filter((v) => v === 1)
                .isSuccess(),
        ).toBe(true)
    })

    it('atry success wrong filter', () => {
        expect(
            atry
                .success(1)
                .filter((v) => v === 2)
                .isFailure(),
        ).toBe(true)
    })

    it('atry failure filter', () => {
        const failureValue = new Error('original failure')
        const result = atry.failure(failureValue).filter((v) => v === 1) // Filter function won't be executed
        expect(result.isFailure()).toBe(true)
        expect(result.failure()).toBe(failureValue)
    })

    it('atry success onSuccess', () => {
        let success = false
        atry.success(1).onSuccess(() => {
            success = true
        })
        expect(success).toBe(true)
    })

    it('atry failure onSuccess', () => {
        let success = false
        atry.failure(new Error('failure')).onSuccess(() => {
            success = true
        })
        expect(success).toBe(false)
    })

    it('atry success onFailure', () => {
        let failure = false
        atry.success(1).onFailure(() => {
            failure = true
        })
        expect(failure).toBe(false)
    })

    it('atry failure onFailure', () => {
        let failureCallbackCalled = false
        atry.failure(new Error('failure')).onFailure(() => {
            failureCallbackCalled = true
        })
        expect(failureCallbackCalled).toBe(true)
    })
})



================================================
FILE: ingest/test/data/tuple.spec.js
================================================
import { describe, it, expect } from 'vitest'
import { Tuple, NEUTRAL, tuple } from '../../lib/data/tuple.js' // Added .js extension

describe('Tuple Data Type Tests', () => {
    it('empty tuple', () => {
        expect(tuple().isEmpty()).toBe(true)
    })

    it('non empty tuple', () => {
        expect(tuple().append(1).isEmpty()).toBe(false)
    })

    it('initiated tuple', () => {
        expect(tuple([2, 4, 6]).value).toEqual([2, 4, 6])
    })

    it('retrieve non empty array', () => {
        expect(new Tuple([1, 2]).array()).toEqual([1, 2])
    })

    it('retrieve joined characters array', () => {
        expect(new Tuple(['1', '2']).join('')).toBe('12')
    })

    it('tuple size', () => {
        const myTuple = new Tuple([1, 2, 3, 4])
        expect(myTuple.size()).toBe(4)
    })

    it('undefined tuple is empty', () => {
        let t = new Tuple()
        expect(t.size()).toBe(0)
        t = t.append(2)
        expect(t.value).toEqual([2])
    })

    it('single is returning the first element of the tuple', () => {
        const l = new Tuple([1, 2])
        expect(l.single()).toBe(1)
    })

    it('NEUTRAL is not added to the tuple', () => {
        let v = NEUTRAL
        let vTuple = tuple().append(NEUTRAL)
        expect(vTuple.size()).toBe(0)
        vTuple = vTuple.append(v).append(3).append(v).append(5)
        expect(vTuple.size()).toBe(2)
        expect(vTuple.array()).toEqual([3, 5])
    })

    it('tuple and NEUTRAL can be added in a Tuple', () => {
        const flat = new Tuple([2, 4, 5])
        const result = tuple()
            .append(NEUTRAL)
            .append(flat)
            .append(1)
            .append(NEUTRAL)
        expect(result).toEqual(new Tuple([2, 4, 5, 1]))
    })

    it('empty tuple append to empty tuple is an empty tuple', () => {
        const result = tuple().append(tuple())
        expect(result).toEqual(tuple())
    })

    it('last() returns the last element', () => {
        const result = new Tuple([2, 4, 6]).last()
        expect(result).toBe(6)
    })

    it('first() returns the first element', () => {
        const result = new Tuple([2, 4, 6]).first()
        expect(result).toBe(2)
    })

    it('at returns the value at index', () => {
        const result = new Tuple([2, 4, 6])
        expect(result.at(1)).toBe(4)
    })

    // Tests for map function
    it('map applies function to each element', () => {
        const original = new Tuple([1, 2, 3])
        const doubled = original.map((x) => x * 2)
        expect(doubled.array()).toEqual([2, 4, 6])
        expect(doubled).toBeInstanceOf(Tuple)
    })

    it('map returns new Tuple instance', () => {
        const original = new Tuple([1, 2, 3])
        const mapped = original.map((x) => x)
        expect(mapped).not.toBe(original)
        expect(mapped).toBeInstanceOf(Tuple)
    })

    it('map on empty tuple returns empty tuple', () => {
        const empty = new Tuple([])
        const mapped = empty.map((x) => x * 2)
        expect(mapped.isEmpty()).toBe(true)
        expect(mapped.array()).toEqual([])
    })

    it('map with string transformation', () => {
        const numbers = new Tuple([1, 2, 3])
        const strings = numbers.map((x) => `num_${x}`)
        expect(strings.array()).toEqual(['num_1', 'num_2', 'num_3'])
    })

    it('map with object transformation', () => {
        const numbers = new Tuple([1, 2, 3])
        const objects = numbers.map((x) => ({ value: x, doubled: x * 2 }))
        expect(objects.array()).toEqual([
            { value: 1, doubled: 2 },
            { value: 2, doubled: 4 },
            { value: 3, doubled: 6 },
        ])
    })

    it('map preserves original tuple unchanged', () => {
        const original = new Tuple([1, 2, 3])
        const originalArray = [...original.value]
        original.map((x) => x * 2)
        expect(original.value).toEqual(originalArray)
    })

    it('map with index parameter', () => {
        const tuple = new Tuple(['a', 'b', 'c'])
        const withIndex = tuple.map((item, index) => `${index}:${item}`)
        expect(withIndex.array()).toEqual(['0:a', '1:b', '2:c'])
    })
})



================================================
FILE: ingest/test/genlex/genlex-brainfuck.spec.js
================================================
import { describe, it, expect } from 'vitest'
import { GenLex } from '../../lib/genlex/genlex'
import { F, C } from '../../lib/core/index' // Added .js extension
import Stream from '../../lib/stream'

function createParser() {
    const genlex = new GenLex()
    genlex.setSeparatorsParser(F.not(C.charIn('+-<>[],.')))
    // Define tokens for each Brainfuck command
    genlex.keywords(['+', '-', '<', '>', '[', ']', ',', '.'])
    // The grammar will collect all recognized tokens
    const grammar = F.any()
        .map((token) => token.value)
        .rep()
    return genlex.use(grammar)
}

describe('GenLex Brainfuck Tokenizer Tests', () => {
    it('parser is valid', () => {
        let hW =
            '++++++++[>++++[>++>+++>+++>+<<<<-]>+>+>->>+[<]<-]>>.>---.+++++++..+++.>>.<-.<.+++.------.--------.>>+.>++.'
        let parser = createParser()
        const response = parser.parse(Stream.ofChars(hW))

        expect(response.isAccepted()).toBe(true)
        // Check if all characters that are commands were tokenized
        // The original test's response.offset was the count of actual Brainfuck command characters.
        const actualBfChars = hW
            .split('')
            .filter((char) => '+-<>[],.'.includes(char)).length
        expect(response.value.size()).toBe(actualBfChars)
        // The GenLex offset would be the number of tokens found.
        expect(response.offset).toBe(actualBfChars)
    })

    it('comments are accepted', () => {
        let hW = `++++++++               Set Cell #0 to 8
[
    >++++               Add 4 to Cell #1; this will always set Cell #1 to 4
    [                   as the cell will be cleared by the loop
        >++             Add 2 to Cell #2
        >+++            Add 3 to Cell #3
        >+++            Add 3 to Cell #4
        >+              Add 1 to Cell #5
        <<<<-           Decrement the loop counter in Cell #1
    ]                   Loop till Cell #1 is zero; number of iterations is 4
    >+                  Add 1 to Cell #2
    >+                  Add 1 to Cell #3
    >-                  Subtract 1 from Cell #4
    >>+                 Add 1 to Cell #6
    [<]                 Move back to the first zero cell you find; this will
                        be Cell #1 which was cleared by the previous loop
    <-                  Decrement the loop Counter in Cell #0
]                       Loop till Cell #0 is zero; number of iterations is 8

Cell No :   0   1   2   3   4   5   6
Contents:   0   0  72 104  88  32   8
Pointer :   ^

>>.                     Cell #2 has value 72 which is 'H'
>---.                   Subtract 3 from Cell #3 to get 101 which is 'e'
+++++++..+++.           Likewise for 'llo' from Cell #3
>>.                     Cell #5 is 32 for the space
<-.                     Subtract 1 from Cell #4 for 87 to give a 'W'
<.                      Cell #3 was set to 'o' from the end of 'Hello'
+++.------.--------.    Cell #3 for 'rl' and 'd'
>>+.                    Add 1 to Cell #5 gives us an exclamation point
>++.                    And finally a newline from Cell #6`

        let parser = createParser()
        const response = parser.parse(Stream.ofChars(hW))

        expect(response.isAccepted()).toBe(true)
        // The original test asserted offset 106. This is the count of actual Brainfuck command characters.
        const bfCommandCharsInString = hW
            .split('')
            .filter((char) => '+-<>[],.'.includes(char)).length
        // response.offset should be the number of tokens (bfCommandCharsInString)
        expect(response.offset).toBe(bfCommandCharsInString)
        expect(response.value.size()).toBe(bfCommandCharsInString)
        expect(bfCommandCharsInString).toBe(106) // Validating the count itself based on original test
    })
})



================================================
FILE: ingest/test/genlex/genlex-coverage.spec.js
================================================
import { describe, it, expect } from 'vitest'

import { leanToken, leanTuple } from '../../lib/genlex/genlex.js'

describe('GenLex lean helpers coverage', () => {
    it('leanToken — returns undefined/null unchanged', () => {
        expect(leanToken(undefined)).toBeUndefined()
        expect(leanToken(null)).toBeNull()
    })

    it('leanToken — returns non-token values as-is', () => {
        expect(leanToken(42)).toBe(42)
        const obj = { a: 1 }
        expect(leanToken(obj)).toBe(obj)
    })

    it('leanTuple — returns undefined/null unchanged', () => {
        expect(leanTuple(undefined)).toBeUndefined()
        expect(leanTuple(null)).toBeNull()
    })

    it('leanTuple — returns non-tuple values as-is', () => {
        const arr = [1, 2]
        expect(leanTuple(arr)).toBe(arr)
        const obj = { x: 1 }
        expect(leanTuple(obj)).toBe(obj)
    })
})



================================================
FILE: ingest/test/genlex/genlex-event-tracer.spec.js
================================================
import { describe, it, expect } from 'vitest'
import { GenlexEventTracer } from '../../lib/genlex/genlex-event-tracer.js'

describe('GenlexEventTracer coverage', () => {
    it('filters events outside window bounds', () => {
        const tracer = new GenlexEventTracer({ window: [10, 20] })
        tracer.emit({ type: 'lex-start', startChar: 5 }) // out, dropped
        tracer.emit({ type: 'lex-start', startChar: 10 }) // in
        tracer.emit({ type: 'lex-start', startChar: 19 }) // in
        tracer.emit({ type: 'lex-start', startChar: 20 }) // out (>= b), dropped

        const events = tracer.flush()
        expect(events.map((e) => e.startChar)).toEqual([10, 19])
    })

    it('excludes reject/mismatch events when includeRejects is false', () => {
        const tracer = new GenlexEventTracer({ includeRejects: false })
        tracer.emit({ type: 'grammar-reject' })
        tracer.emit({ type: 'mismatch' })
        tracer.emit({ type: 'lex-commit' })

        const events = tracer.flush()
        expect(events.map((e) => e.type)).toEqual(['lex-commit'])
    })

    it('getLastTokenMeta returns value set by setLastTokenMeta', () => {
        const tracer = new GenlexEventTracer()
        expect(tracer.getLastTokenMeta()).toBeUndefined()
        const meta = { tokenIndex: 3, startChar: 10, endChar: 12 }
        tracer.setLastTokenMeta(meta)
        expect(tracer.getLastTokenMeta()).toEqual(meta)
    })
})



================================================
FILE: ingest/test/genlex/genlex-nospace.spec.js
================================================
import { describe, it, expect } from 'vitest'

import { GenLex } from '../../lib/index.js'
import stream from '../../lib/stream/index.js'

describe('GenLex Tests with nospace', () => {
    it('genlex.noSeparators() wont accept if spaces are present', () => {
        const genlex = new GenLex().noSeparator()
        const [plus, minus] = genlex.keywords(['+', '-'])
        let grammar = plus.or(minus).rep().thenEos()
        const parser = genlex.use(grammar)
        const text = '+ + - --'
        const parsing = parser.parse(stream.ofChars(text))

        expect(parsing.isEos()).toBe(false)
        expect(parsing.offset).toBe(1)
    })

    it('genlex.noSeparators() will accept if spaces are NOT present', () => {
        const genlex = new GenLex().noSeparator()
        const [plus, minus] = genlex.keywords(['+', '-'])
        let grammar = plus.or(minus).rep().thenEos()
        const parser = genlex.use(grammar)
        const text = '+-+---'
        const parsing = parser.parse(stream.ofChars(text))

        expect(parsing.isEos()).toBe(true)
        expect(parsing.offset).toBe(6)
    })

    it('reset with spaces with setSeparators', () => {
        let genlex = new GenLex().noSeparator()
        genlex.setSeparators('=')
        const [plus, minus] = genlex.keywords(['+', '-'])
        let grammar = plus.or(minus).rep().thenEos()
        const parser = genlex.use(grammar)
        const text = '+=-=+=='
        const parsing = parser.parse(stream.ofChars(text))

        expect(parsing.isEos()).toBe(true)
        expect(parsing.offset).toBe(3)
    })
})



================================================
FILE: ingest/test/genlex/genlex-priority.spec.js
================================================
import { describe, it, expect } from 'vitest'

import { GenLex } from '../../lib/index.js'
import stream from '../../lib/stream/index.js'

describe('GenLex priorities', () => {
    it('give bad result if no priorities', () => {
        const genlex = new GenLex()
        const [one, two] = genlex.keywords(['<', '<='])
        let grammar = one.or(two).rep().thenEos()
        const parser = genlex.use(grammar)

        /**
         * '<' has priority on '<='
         * The problem here is that '<' will be picked first,
         * giving no chance to '<=' token
         **/
        const text = '<='

        const parsing = parser.parse(stream.ofChars(text))

        expect(parsing.isEos()).toBe(false) // stopping at '<', not reaching '='
        expect(parsing.offset).toBe(1)
        // raw text index
        expect(parsing.input.location(parsing.offset)).toBe(1)
    })

    it('keywords respects priorities', () => {
        const genlex = new GenLex()
        const [one, two] = genlex.keywords(['<=', '<'])
        let grammar = one.or(two).rep().thenEos()
        const parser = genlex.use(grammar)

        /**
         * '<=' has priority on '<'
         * Now we start by trying  '<=' before '<'
         **/
        const text = '<='

        const parsing = parser.parse(stream.ofChars(text))

        expect(parsing.isEos()).toBe(true) //  reaching '='
        expect(parsing.offset).toBe(1)
        // raw text index
        expect(parsing.input.location(parsing.offset)).toBe(2)
    })

    it('tokenize respects priorities with bad result', () => {
        const genlex = new GenLex()
        const one = genlex.tokenize('<', 'LT')
        const two = genlex.tokenize('<=', 'LTE')
        let grammar = one.or(two).rep().thenEos()
        const parser = genlex.use(grammar)

        const text = '<='

        const parsing = parser.parse(stream.ofChars(text))

        expect(parsing.isEos()).toBe(false) //  reaching '='
        expect(parsing.offset).toBe(1)
        // raw text index
        expect(parsing.input.location(parsing.offset)).toBe(1)
    })

    it('tokenize respects priorities with expected result', () => {
        const genlex = new GenLex()
        const one = genlex.tokenize('<=', 'LTE')
        const two = genlex.tokenize('<', 'LT')
        let grammar = one.or(two).rep().thenEos()
        const parser = genlex.use(grammar)

        const text = '<='

        const parsing = parser.parse(stream.ofChars(text))

        expect(parsing.isEos()).toBe(true) //  reaching '='
        expect(parsing.offset).toBe(1)
        // raw text index
        expect(parsing.input.location(parsing.offset)).toBe(2)
    })
})



================================================
FILE: ingest/test/genlex/genlex-tracer-minimal.spec.js
================================================
import { describe, it, expect } from 'vitest'
import { TracingGenLex } from '../../lib/genlex/tracing-genlex.js'

import { F, GenLex } from '../../lib/index.js'
import stream from '../../lib/stream/index.js'
import { GenlexEventTracer } from '../../lib/genlex/genlex-event-tracer.js'

function createClassicMinimalParser() {
    const genlex = new GenLex()
    genlex.keywords(['A', 'B', 'C'])
    // The grammar will collect all recognized tokens
    const grammar = F.any()
        .map((token) => token.value)
        .rep()
        .thenEos()
    return genlex.use(grammar)
}

function createTracedMinimalParser(tracer) {
    const genlex = new TracingGenLex(tracer)
    genlex.keywords(['A', 'B', 'C'])
    // The grammar will collect all recognized tokens
    const grammar = F.any()
        .map((token) => token.value)
        .rep()
        .thenEos()
    return { parser: genlex.use(grammar), tracer: genlex.tracer }
}

function createTracedSimpleParser(tracer) {
    const genlex = new TracingGenLex(tracer)
    const [a, b] = genlex.keywords(['A', 'B', 'C'])
    const grammar = a.then(b).then(F.any().rep()).thenEos()
    return { parser: genlex.use(grammar), tracer: genlex.tracer }
}

describe('Classic GenLex Tokenizer Tests', () => {
    it('parser is valid', () => {
        let parser = createClassicMinimalParser()

        const response = parser.parse(stream.ofChars('A B C A C B A A C'))
        expect(response.isAccepted()).toBe(true)
        expect(response.value.size()).toBe(9)
        expect(response.value.join('')).toBe('ABCACBAAC')
    })
})

describe('Tracing GenLex Tokenizer Tests', () => {
    it('parser is valid', () => {
        const { parser } = createTracedMinimalParser()
        const response = parser.parse(stream.ofChars('A B C A C B A A C'))

        expect(response.isAccepted()).toBe(true)
        expect(response.value.size()).toBe(9)
        expect(response.value.join('')).toBe('ABCACBAAC')
    })

    it('minimal grammar — emits lex events with metadata (no grammar-accept with F.any())', () => {
        const tracer = new GenlexEventTracer()
        const { parser, tracer: boundTracer } =
            createTracedMinimalParser(tracer)
        const input = 'A B C A C B A A C'
        const response = parser.parse(stream.ofChars(input))

        expect(response.isAccepted()).toBe(true)
        expect(response.value.join('')).toBe('ABCACBAAC')

        const events = boundTracer.flush()
        const commits = events.filter((e) => e.type === 'lex-commit')
        const accepts = events.filter((e) => e.type === 'grammar-accept')

        expect(commits.length).toBe(9)
        expect(accepts.length).toBe(0)

        const commitIdxs = commits.map((e) => e.tokenIndex)
        expect(commitIdxs).toEqual([0, 1, 2, 3, 4, 5, 6, 7, 8])

        for (let i = 0; i < 9; i++) {
            expect(typeof commits[i].startChar).toBe('number')
            expect(typeof commits[i].endChar).toBe('number')
            expect(commits[i].startChar).toBeLessThanOrEqual(commits[i].endChar)
        }
        expect(commits[8].trailing).toBe(0)
    })

    it('simple grammar — accept: emits grammar-accept for A,B and lex-commit for all tokens', () => {
        const tracer = new GenlexEventTracer()
        const { parser, tracer: boundTracer } = createTracedSimpleParser(tracer)
        const response = parser.parse(stream.ofChars('A B CC'))
        expect(response.isAccepted()).toBe(true)

        const events = boundTracer.flush()
        const commits = events.filter((e) => e.type === 'lex-commit')
        const accepts = events.filter((e) => e.type === 'grammar-accept')

        expect(commits.length).toBe(4)
        expect(accepts.length).toBe(2)
        expect(accepts.map((e) => e.name)).toEqual(['A', 'B'])
        expect(accepts.map((e) => e.tokenIndex)).toEqual([0, 1])
        expect(commits.map((e) => e.tokenIndex)).toEqual([0, 1, 2, 3])
    })

    it('simple grammar — grammar-reject when next token mismatches (A C B)', () => {
        const tracer = new GenlexEventTracer()
        const { parser, tracer: boundTracer } = createTracedSimpleParser(tracer)
        const response = parser.parse(stream.ofChars('A C B'))
        expect(response.isAccepted()).toBe(false)

        const events = boundTracer.flush()
        const accepts = events.filter((e) => e.type === 'grammar-accept')
        const rejects = events.filter((e) => e.type === 'grammar-reject')
        const commits = events.filter((e) => e.type === 'lex-commit')

        expect(accepts.map((e) => e.name)).toEqual(['A'])
        expect(commits.length).toBe(2)
        expect(rejects.length).toBe(1)
        expect(rejectsFields(rejects[0])).toEqual({ expected: 'B', found: 'C' })
        expect(rejects[0].tokenIndex).toBe(1)
    })

    it('simple grammar — lex-fail when an unknown token is encountered (A B CDC)', () => {
        const tracer = new GenlexEventTracer()
        const { parser, tracer: boundTracer } = createTracedSimpleParser(tracer)
        const response = parser.parse(stream.ofChars('A B CDC'))
        expect(response.isAccepted()).toBe(false)

        const events = boundTracer.flush()
        const fails = events.filter((e) => e.type === 'lex-fail')
        const commits = events.filter((e) => e.type === 'lex-commit')
        const accepts = events.filter((e) => e.type === 'grammar-accept')

        expect(accepts.map((e) => e.name)).toEqual(['A', 'B'])
        expect(commits.length).toBe(3)
        expect(fails.length).toBe(1)
    })

    it('simple grammar — grammar-eos on empty input', () => {
        const tracer = new GenlexEventTracer()
        const { parser, tracer: boundTracer } = createTracedSimpleParser(tracer)
        const response = parser.parse(stream.ofChars(''))
        expect(response.isAccepted()).toBe(false)

        const events = boundTracer.flush()
        const eos = events.filter((e) => e.type === 'grammar-eos')
        const lex = events.filter((e) => e.type.startsWith('lex-'))

        expect(eos.length).toBe(1)
        expect(eos[0].expected).toBe('A')
        expect(lex.length).toBe(0)
    })

    it('simple grammar — spaces-only: emits lex-fail and grammar-eos', () => {
        const tracer = new GenlexEventTracer()
        const { parser, tracer: boundTracer } = createTracedSimpleParser(tracer)
        const response = parser.parse(stream.ofChars('   '))
        expect(response.isAccepted()).toBe(false)

        const events = boundTracer.flush()
        const starts = events.filter((e) => e.type === 'lex-start')
        const fails = events.filter((e) => e.type === 'lex-fail')
        const eos = events.filter((e) => e.type === 'grammar-eos')

        expect(starts.length).toBe(1)
        expect(fails.length).toBe(1)
        expect(eos.length).toBe(1)
        expect(eos[0].expected).toBe('A')
    })

    it('keywords() in TracingGenLex yields TokenValue in token stream', () => {
        const genlex = new TracingGenLex()
        const [a] = genlex.keywords(['A'])
        const parser = genlex.use(a.thenEos())
        const res = parser.parse(stream.ofChars('A'))
        expect(res.isAccepted()).toBe(true)
        const tok = res.value.at(0)
        expect(typeof tok).toBe('object')
        expect(tok.name).toBe('A')
        expect(tok.value).toBe('A')
    })

    it('tokenize() in TracingGenLex yields TokenValue in token stream', () => {
        const genlex = new TracingGenLex()
        const plus = genlex.tokenize('+', 'plus')
        const parser = genlex.use(plus.thenEos())
        const res = parser.parse(stream.ofChars('+'))
        expect(res.isAccepted()).toBe(true)
        const tok = res.value.at(0)
        expect(typeof tok).toBe('object')
        expect(tok.name).toBe('plus')
        expect(tok.value).toBe('+')
    })

    it('F.any() sees TokenValue with tracing and can map to raw values', () => {
        const genlex = new TracingGenLex()
        genlex.keywords(['A', 'B'])
        const parser = genlex.use(
            F.any()
                .map((tv) => tv.value)
                .rep()
                .thenEos(),
        )
        const res = parser.parse(stream.ofChars('A B'))
        expect(res.isAccepted()).toBe(true)
        expect(res.value.array()).toEqual(['A', 'B'])
    })
})

function rejectsFields(e) {
    return { expected: e.expected, found: e.found }
}



================================================
FILE: ingest/test/genlex/genlex.spec.js
================================================
import { describe, it, expect } from 'vitest'
import { F, C, N } from '../../lib/core'
import {
    GenLex,
    getMathGenLex,
    anyToken,
    leanTuple,
} from '../../lib/genlex/genlex'
import stream from '../../lib/stream'

// Helper function from the original test file
function dateParser() {
    // Renamed from date() to avoid conflict if imported elsewhere
    return N.digits()
        .then(C.charIn(['-', '/']).returns('-')) // Standardize separator for join
        .then(N.digits())
        .then(C.charIn(['-', '/']).returns('-'))
        .then(N.digits())
        .map((dateValues) =>
            dateValues[4] > 2000 ? dateValues.reverse() : dateValues,
        )
        .map((dateArray) => dateArray.join(''))
}

describe('GenLex Tests', () => {
    it('genlex find offsets when success', () => {
        const genlex = new GenLex()
        const plus = genlex.tokenize('+')
        const minus = genlex.tokenize('-')
        let grammar = plus.or(minus).rep().thenEos()
        const parser = genlex.use(grammar)
        const text = '+ + - --'
        const parsing = parser.parse(stream.ofChars(text))

        expect(parsing.isEos()).toBe(true)
        expect(parsing.offset).toBe(5)
        expect(parsing.input.location(parsing.offset)).toBe(8)
    })

    it('genlex find offsets when fail', () => {
        const genlex = new GenLex()
        const plus = genlex.tokenize('+')
        const minus = genlex.tokenize('-')
        let grammar = plus.or(minus).rep().thenEos()
        const parser = genlex.use(grammar)
        const text = '+  +  +* --'
        const parsing = parser.parse(stream.ofChars(text))

        expect(parsing.isEos()).toBe(false)
        expect(parsing.getOffset()).toBe(3)
        expect(parsing.location()).toBe(7)
    })

    it('expect Genlex to be constructed with spaces ', () => {
        const genlex = new GenLex()
        expect(genlex.spaces).toBeDefined()
        expect(genlex.definitions.length).toBe(0)
    })

    it('expect tokenize() to add on definition', () => {
        const genlex = new GenLex()
        genlex.tokenize(N.number(), 'number', 500)
        expect(genlex.definitions.length).toBe(1)
    })

    it('expect use() to sort definitions by revert priority', () => {
        const genlex = new GenLex()
        const tkNumber = genlex.tokenize(N.number(), 'number')
        const tkDate = genlex.tokenize(dateParser(), 'date', 800)
        const tkChar = genlex.tokenize(C.charLiteral(), 'char', 1200)
        let grammar = tkDate.then(tkNumber.rep().or(tkChar))

        genlex.use(grammar)
        expect(genlex.definitions[0].name).toBe('char')
        expect(genlex.definitions[2].name).toBe('date')
        expect(genlex.definitions[1].name).toBe('number')
    })

    it('expect use() to create an easy tokenizer', () => {
        const genlex = new GenLex()
        const tkNumber = genlex.tokenize(N.number(), 'number')
        let grammar = tkNumber.rep()
        const parser = genlex.use(grammar)
        const parsing = parser.parse(stream.ofChars('34 23'))
        expect(parsing.isAccepted()).toBe(true)
    })

    it('GenLex can tokenize keywords', () => {
        const genlex = new GenLex()
        const plus = genlex.tokenize('+')
        let grammar = plus.rep().then(F.eos().drop())
        const parser = genlex.use(grammar)
        const text = '+++++'
        const parsing = parser.parse(stream.ofChars(text))
        expect(parsing.isAccepted()).toBe(true)
    })

    it('tokenize mixes with keywords', () => {
        const genlex = new GenLex()
        const number = genlex.tokenize(N.number(), 'number')
        const plus = genlex.tokenize('+')
        let grammar = plus.or(number).rep().then(F.eos().drop())
        const parser = genlex.use(grammar)
        const text = '++77++4+'
        const parsing = parser.parse(stream.ofChars(text))
        expect(parsing.isEos()).toBe(true)
    })

    it('getMathGenLex() gives a simple genlex', () => {
        const genlex = getMathGenLex()
        const number = genlex.get('number')
        let grammar = number.rep()
        const text = '15 14'
        const parser = genlex.use(grammar)
        const parsing = parser.parse(stream.ofChars(text))
        const tokenValues = parsing.value.array().map((tv) => tv.value)
        expect(tokenValues).toEqual([15, 14])
    })

    it('getMathGenLex can be enhanced with a parser', () => {
        const genlex = getMathGenLex()
        genlex.remove('-')
        const number = genlex.get('number')
        const tkDate = genlex.tokenize(dateParser(), 'date', 800)
        let grammar = tkDate.rep().then(number).then(F.eos())
        const text = '15-12-2018      12-02-2020   12 '
        const parser = genlex.use(grammar)
        const parsing = parser.parse(stream.ofChars(text))
        expect(parsing.isAccepted()).toBe(true)
    })

    it('getMathGenLex can be enhanced with a string', () => {
        const genlex = getMathGenLex()
        const number = genlex.get('number')
        const dol = genlex.tokenize('$', 'dol')
        let grammar = number.then(dol).rep().then(F.eos())
        const text = '15 $ '
        const parser = genlex.use(grammar)
        const parsing = parser.parse(stream.ofChars(text))
        expect(parsing.isEos()).toBe(true)
    })

    it('getMathGenLex can be enhanced with a string and no name', () => {
        const genlex = getMathGenLex()
        const number = genlex.get('number')
        genlex.tokenize('$')
        const dol = genlex.get('$')
        let grammar = number.then(dol).rep().then(F.eos())
        const text = '15 $ '
        const parsing = genlex.use(grammar).parse(stream.ofChars(text))
        expect(parsing.isEos()).toBe(true)
    })

    it('genlex can change separators with a given string', () => {
        const genlex = getMathGenLex()
        const number = genlex.get('number')
        let grammar = number.rep().then(F.eos().drop())
        genlex.setSeparators('-')
        const text = '15-12-35--'
        const parser = genlex.use(grammar)
        const parsing = parser.parse(stream.ofChars(text))
        expect(parsing.isAccepted()).toBe(true)
        const tokenValues = parsing.value.array().map((tv) => tv.value)
        expect(tokenValues).toEqual([15, 12, 35])
    })

    it('genlex separators must be a string', () => {
        const genlex = getMathGenLex()
        expect(() => genlex.setSeparators(1)).toThrow()
    })

    // anyToken(genlex)
    it('anyToken parses a stream of declared keywords', () => {
        const genlex = new GenLex()
        genlex.keywords(['A', 'B', 'C'])
        const grammar = anyToken(genlex).rep().thenEos()
        const parser = genlex.use(grammar)
        const parsing = parser.parse(stream.ofChars('A B C A'))
        expect(parsing.isAccepted()).toBe(true)
        expect(parsing.value.array().map((tv) => tv.value)).toEqual([
            'A',
            'B',
            'C',
            'A',
        ])
    })

    it('anyToken fails when next token is not recognized', () => {
        const genlex = new GenLex()
        genlex.keywords(['A', 'B'])
        const grammar = anyToken(genlex).rep().thenEos()
        const parser = genlex.use(grammar)
        const parsing = parser.parse(stream.ofChars('A X'))
        expect(parsing.isAccepted()).toBe(false)
        expect(parsing.getOffset()).toBe(1)
    })

    // New tests about keywords() kind of parser and TokenValue timing
    it('keywords returns token-stream parsers (not char parsers)', () => {
        const genlex = new GenLex()
        const [a] = genlex.keywords(['A', 'B'])
        // Using keyword parser directly on a char stream should fail
        const direct = a.parse(stream.ofChars('A'))
        expect(direct.isAccepted()).toBe(false)
        // Using within a token stream (via use) should work
        const parser = genlex.use(a.thenEos())
        const res = parser.parse(stream.ofChars('A'))
        expect(res.isAccepted()).toBe(true)
        expect(res.value.at(0).value).toBe('A')
    })

    it('F.any after use yields TokenValue; keyword parser maps to raw value', () => {
        const genlex1 = new GenLex()
        genlex1.keywords(['A', 'B'])
        // F.any() should see TokenValue instances and we can map to underlying values
        const parserAny = genlex1.use(
            F.any()
                .map((tv) => tv.value)
                .rep()
                .thenEos(),
        )
        const anyRes = parserAny.parse(stream.ofChars('A B'))
        expect(anyRes.isAccepted()).toBe(true)
        expect(anyRes.value.array()).toEqual(['A', 'B'])

        const genlex2 = new GenLex()
        const [a] = genlex2.keywords(['A'])
        const parserA = genlex2.use(a.thenEos())
        const aRes = parserA.parse(stream.ofChars('A'))
        expect(aRes.isAccepted()).toBe(true)
        // keyword parser maps TokenValue to raw token value (wrapped in a Tuple by thenEos)
        expect(aRes.value.at(0).value).toBe('A')
    })

    it('Genlex F.any yields wrapped values', () => {
        const genlex1 = new GenLex()
        genlex1.keywords(['A', 'B'])
        // F.any() over the token stream should see TokenResult instances currently
        const anyParser = genlex1.use(F.any().rep().thenEos())
        const anyResponse = anyParser.parse(stream.ofChars('A B'))
        expect(anyResponse.isAccepted()).toBe(true)
        const result = anyResponse.value
        expect(result.at(0).value).toEqual('A')
        expect(leanTuple(anyResponse.value)).toEqual(['A', 'B'])
    })

    it('Genlex tokenize yields wrapped values', () => {
        const genlexAB = new GenLex()
        const a = genlexAB.tokenize('A', 'a')
        const b = genlexAB.tokenize('B', 'b')
        const parserAThenB = genlexAB.use(a.then(b).thenEos())
        const response = parserAThenB.parse(stream.ofChars('A B'))
        const result = response.value
        expect(response.isAccepted()).toBe(true)
        expect(result.at(0).value).toBe('A')
        expect(leanTuple(result)).toEqual(['A', 'B'])
    })

    it('Genlex keywords yields wrapped values', () => {
        const genlex1 = new GenLex()
        const [a, b] = genlex1.keywords(['A', 'B'])
        // F.any() over the token stream should see TokenValue instances currently
        const parserAThenB = genlex1.use(a.then(b).thenEos())
        const response = parserAThenB.parse(stream.ofChars('A B'))
        const result = response.value

        expect(response.isAccepted()).toBe(true)
        expect(result.at(0).value).toBe('A')
        expect(leanTuple(result)).toEqual(['A', 'B'])
    })
})



================================================
FILE: ingest/test/genlex/tracing-genlex-coverage.spec.js
================================================
import { describe, it, expect } from 'vitest'
import { TracingGenLex, getSnippet } from '../../lib/genlex/tracing-genlex.js'

import stream from '../../lib/stream/index.js'

describe('TracingGenLex coverage additions', () => {
    it("tokenize(string) — defaults token name to the string when name isn't provided", () => {
        const gl = new TracingGenLex()
        const tok = gl.tokenize('+')
        expect(tok.__token__name).toBe('+')

        const parser = gl.use(tok.thenEos())
        const res = parser.parse(stream.ofChars('+'))
        expect(res.isAccepted()).toBe(true)
        const tv = res.value.at(0)
        expect(tv.name).toBe('+')
        expect(tv.value).toBe('+')
    })

    it('getSnippet — returns undefined for non-string input', () => {
        const fakeInput = {}
        expect(getSnippet(fakeInput, 0)).toBeUndefined()
    })

    it('getSnippet — returns empty string when startChar is undefined', () => {
        const s = stream.ofChars('ABC')
        expect(getSnippet(s, undefined)).toBe('')
    })

    it('getSnippet — truncates when longer than maxLength', () => {
        const s = stream.ofChars('abcdefghijklmnopqr')
        expect(getSnippet(s, 0, 8)).toBe('abcdefgh...')
    })

    /*
    it('grammar-reject with missing token name — found is null', () => {
        const tracer = new EventTracer()
        const gl = new TracingGenLex(tracer)
        const a = gl.tokenize('A')

        // Provide an object without a name so foundName is undefined
        const res = a.parse(stream.ofArrays([{}]))
        expect(res.isAccepted()).toBe(false)

        const events = tracer.flush()
        const rejects = events.filter((e) => e.type === 'grammar-reject')
        expect(rejects.length).toBe(1)
        // Branch: foundName ?? null
        expect(rejects[0].found).toBeNull()
    })*/
})



================================================
FILE: ingest/test/genlex/tracing-genlex-flush.spec.js
================================================
import { describe, it, expect } from 'vitest'
import { TracingGenLex, getSnippet } from '../../lib/genlex/tracing-genlex.js'

import stream from '../../lib/stream/index.js'

let genLexInstance = null
function ifElseParser() {
    const genLex = new TracingGenLex()
    const [_if, _else, a, b] = genLex.keywords(['if', 'else', 'A', 'B'])

    const grammar = _if.then(a).then(_else.then(b).opt()).thenEos()
    genLexInstance = genLex
    return genLex.use(grammar)
}

describe('TracingGenLex flush', () => {
    it('flush returns and clears events', () => {
        const grammar = ifElseParser()
        const input = stream.ofChars('if A else B')
        const res = grammar.parse(input)
        //expect(res.isAccepted()).toBe(true)

        const logs = genLexInstance.flush()
        const json = JSON.stringify(logs, null, 2)
        expect(logs.length).toBeGreaterThan(0)

        expect(json.includes('"type": "lex-taken"')).toBe(true)
        expect(json.includes('"type": "lex-try"')).toBe(true)
    })

    it('flush simple events', () => {
        const grammar = ifElseParser()
        const input = stream.ofChars('if A else B')
        const res = grammar.parse(input)
        expect(res.isAccepted()).toBe(true)

        const logs = genLexInstance.flushForAi()
        const json = JSON.stringify(logs, null, 2)
        expect(logs.length).toBeGreaterThan(0)

        expect(json.includes('"type": "lex-taken"')).toBe(true)
        expect(json.includes('"type": "lex-try"')).toBe(false)
    })
})



================================================
FILE: ingest/test/parsec/chars-bundle-regex.spec.js
================================================
import { describe, it, expect } from 'vitest'
import Stream from '../../lib/stream/index'
import { N, C } from '../../lib/core/index'

describe('Chars Bundle Tests', () => {
    it('accepts a character inside the range', () => {
        const parsing = C.inRegexRange('a-z').parse(Stream.ofChars('c'))
        expect(parsing.isAccepted()).toBe(true)
        expect(parsing.value).toBe('c')
        expect(parsing.offset).toBe(1) // consumed one char
    })

    it('rejects a character outside the range', () => {
        const parsing = C.inRegexRange('a-z').parse(Stream.ofChars('Z'))
        expect(parsing.isAccepted()).toBe(false)
        expect(parsing.offset).toBe(0) // cursor untouched on failure
    })

    it('accepts a digit with /[0-9]/', () => {
        const parsing = C.inRegexRange('0-9').parse(Stream.ofChars('7'))
        expect(parsing.isAccepted()).toBe(true)
        expect(parsing.value).toBe('7')
    })

    it('rejects a letter with /[0-9]/', () => {
        const parsing = C.inRegexRange('0-9').parse(Stream.ofChars('a'))
        expect(parsing.isAccepted()).toBe(false)
    })
})

describe('C.inRegexRange – identifier “first char” rule', () => {
    const identStart = C.inRegexRange('a-zA-Z_')

    it('accepts a letter', () => {
        expect(identStart.parse(Stream.ofChars('B')).isAccepted()).toBe(true)
    })

    it('accepts an underscore', () => {
        expect(identStart.parse(Stream.ofChars('_')).isAccepted()).toBe(true)
    })

    it('rejects a digit', () => {
        expect(identStart.parse(Stream.ofChars('3')).isAccepted()).toBe(false)
    })
})

describe('C.inRegexRange in a more complex stream', () => {
    it('accepts the string', () => {
        const stream = Stream.ofChars('0a1')
        const parser = N.digit().then(C.inRegexRange('a-c')).then(N.digit())
        const parsing = parser.parse(stream)
        expect(parsing.isAccepted()).toBe(true)
        expect(parsing.offset).toBe(3)
    })

    it('reject the range', () => {
        const stream = Stream.ofChars('0d1')
        const parser = N.digit().then(C.inRegexRange('a-c')).then(N.digit())
        const parsing = parser.parse(stream)
        expect(parsing.isAccepted()).toBe(false)
        expect(parsing.offset).toBe(1)
    })
})



================================================
FILE: ingest/test/parsec/chars-bundle-test.spec.js
================================================
import { describe, it, expect } from 'vitest'
import Stream from '../../lib/stream/index'
import { F, C } from '../../lib/core/index'

describe('Chars Bundle Tests', () => {
    it('expect (char) to be accepted', () => {
        expect(C.char('a').parse(Stream.ofChars('a'), 0).isAccepted()).toBe(
            true,
        )
    })

    it('expect (char) to be rejected', () => {
        expect(C.char('a').parse(Stream.ofChars('b'), 0).isAccepted()).toBe(
            false,
        )
    })

    it('expect (char) to be refused', () => {
        expect(() => C.char('aa')).toThrow()
    })

    it('expect (notChar) to be accepted', () => {
        expect(C.notChar('a').parse(Stream.ofChars('b'), 0).isAccepted()).toBe(
            true,
        )
    })

    it('expect (notChar) to be rejected', () => {
        expect(C.notChar('a').parse(Stream.ofChars('a'), 0).isAccepted()).toBe(
            false,
        )
    })

    it('expect (notChar) to be refused', () => {
        expect(() => C.notChar('aa')).toThrow()
    })

    it('expect (charNotIn) to be accepted', () => {
        expect(
            C.charNotIn('a').parse(Stream.ofChars('b'), 0).isAccepted(),
        ).toBe(true)
    })

    it('expect (charNotIn) to be rejected', () => {
        expect(
            C.charNotIn('a').parse(Stream.ofChars('a'), 0).isAccepted(),
        ).toBe(false)
    })

    it('expect (charIn) to be accepted', () => {
        expect(C.charIn('a').parse(Stream.ofChars('a'), 0).isAccepted()).toBe(
            true,
        )
    })

    it('expect (charIn) to be rejected', () => {
        expect(C.charIn('a').parse(Stream.ofChars('b'), 0).isAccepted()).toBe(
            false,
        )
    })

    it('expect (lowerCase) to be accepted', () => {
        expect(C.lowerCase().parse(Stream.ofChars('a'), 0).isAccepted()).toBe(
            true,
        )
    })

    it('expect (lowerCase) to be rejected', () => {
        expect(C.lowerCase().parse(Stream.ofChars('A'), 0).isAccepted()).toBe(
            false,
        )
    })

    it('expect (upperCase) to be accepted', () => {
        expect(C.upperCase().parse(Stream.ofChars('A'), 0).isAccepted()).toBe(
            true,
        )
    })

    it('expect (upperCase) to be rejected', () => {
        expect(C.upperCase().parse(Stream.ofChars('z'), 0).isAccepted()).toBe(
            false,
        )
    })

    it('expect upper (letter) to be accepted', () => {
        expect(C.letter().parse(Stream.ofChars('A'), 0).isAccepted()).toBe(true)
    })

    it('expect lower (letter) to be accepted', () => {
        expect(C.letter().parse(Stream.ofChars('z'), 0).isAccepted()).toBe(true)
    })

    it('expect space (letter) to be rejected', () => {
        expect(C.letter().parse(Stream.ofChars(' '), 0).isAccepted()).toBe(
            false,
        )
    })

    it('expect non (letter) to be rejected', () => {
        expect(C.letter().parse(Stream.ofChars('0'), 0).isAccepted()).toBe(
            false,
        )
    })

    it('expect occidental letter to be accepted', () => {
        expect(C.letter().parse(Stream.ofChars('a'), 0).isAccepted()).toBe(true)
        expect(C.letterAs().parse(Stream.ofChars('a'), 0).isAccepted()).toBe(
            true,
        )
        expect(
            C.letterAs(C.OCCIDENTAL_LETTER)
                .parse(Stream.ofChars('a'))
                .isAccepted(),
        ).toBe(true)
        expect(
            C.letterAs(C.OCCIDENTAL_LETTER)
                .parse(Stream.ofChars('é'))
                .isAccepted(),
        ).toBe(true)
        expect(
            C.letterAs(C.OCCIDENTAL_LETTER)
                .parse(Stream.ofChars('Б'))
                .isAccepted(),
        ).toBe(false)
        expect(
            C.letterAs(C.OCCIDENTAL_LETTER)
                .parse(Stream.ofChars('÷'))
                .isAccepted(),
        ).toBe(false)
    })

    it('expect occidental letters to be accepted', () => {
        expect(
            C.letters()
                .then(F.eos())
                .parse(Stream.ofChars('aéÉ'), 0)
                .isAccepted(),
        ).toBe(true)
        expect(
            C.lettersAs()
                .then(F.eos())
                .parse(Stream.ofChars('aéÉ'), 0)
                .isAccepted(),
        ).toBe(true)
        expect(
            C.lettersAs(C.OCCIDENTAL_LETTER)
                .parse(Stream.ofChars('a'))
                .isAccepted(),
        ).toBe(true)
        expect(
            C.lettersAs(C.OCCIDENTAL_LETTER)
                .then(F.eos())
                .parse(Stream.ofChars('éA'))
                .isAccepted(),
        ).toBe(true)
        expect(
            C.lettersAs(C.OCCIDENTAL_LETTER)
                .then(F.eos())
                .parse(Stream.ofChars('БAs'))
                .isAccepted(),
        ).toBe(false)
    })

    it('expect ascii letter to be accepted', () => {
        expect(
            C.letterAs(C.ASCII_LETTER)
                .parse(Stream.ofChars('a'), 0)
                .isAccepted(),
        ).toBe(true)
        expect(
            C.letterAs(C.ASCII_LETTER).parse(Stream.ofChars('é')).isAccepted(),
        ).toBe(false)
        expect(
            C.letterAs(C.ASCII_LETTER).parse(Stream.ofChars('Б')).isAccepted(),
        ).toBe(false)
    })

    it('expect ascii letters to be accepted', () => {
        expect(
            C.lettersAs(C.ASCII_LETTER)
                .then(F.eos())
                .parse(Stream.ofChars('a'))
                .isAccepted(),
        ).toBe(true)
    })

    it('expect utf8 letter to be accepted', () => {
        expect(
            C.letterAs(C.UTF8_LETTER).parse(Stream.ofChars('a')).isAccepted(),
        ).toBe(true)
        expect(
            C.letterAs(C.UTF8_LETTER).parse(Stream.ofChars('é')).isAccepted(),
        ).toBe(true)
        expect(
            C.letterAs(C.UTF8_LETTER).parse(Stream.ofChars('Б')).isAccepted(),
        ).toBe(true)
        expect(
            C.letterAs(C.UTF8_LETTER).parse(Stream.ofChars('÷')).isAccepted(),
        ).toBe(false)
    })

    it('expect utf8 letters to be accepted', () => {
        expect(
            C.lettersAs(C.UTF8_LETTER)
                .then(F.eos())
                .parse(Stream.ofChars('a'))
                .isAccepted(),
        ).toBe(true)
        expect(
            C.lettersAs(C.UTF8_LETTER)
                .then(F.eos())
                .parse(Stream.ofChars('éA'))
                .isAccepted(),
        ).toBe(true)
        expect(
            C.lettersAs(C.UTF8_LETTER)
                .then(F.eos())
                .parse(Stream.ofChars('БAs'))
                .isAccepted(),
        ).toBe(true)
        expect(
            C.letterAs(C.UTF8_LETTER)
                .then(F.eos())
                .parse(Stream.ofChars('Б÷As'))
                .isAccepted(),
        ).toBe(false)
    })

    it('expect unknown letters to be rejected', () => {
        const line = Stream.ofChars('a')
        expect(() => {
            const combinator = C.lettersAs(Symbol('UNKNOWN')).then(F.eos())
            combinator.parse(line)
        }).toThrow()
    })

    it('expect (letters) to be accepted', () => {
        const parsing = C.letters()
            .thenLeft(F.eos())
            .single()
            .parse(Stream.ofChars('someLetters'), 0)
        expect(parsing.isAccepted()).toBe(true)
        expect(parsing.value).toBe('someLetters')
    })

    it('expect (letters) with space to be rejected', () => {
        const parsing = C.letters()
            .then(F.eos())
            .parse(Stream.ofChars('some Letters'), 0)
        expect(parsing.isAccepted()).toBe(false)
        expect(parsing.offset).toBe(4)
    })

    it('expect (letters) with number to be rejected', () => {
        const parsing = C.letters()
            .then(F.eos())
            .parse(Stream.ofChars('some2Letters'), 0)
        expect(parsing.isAccepted()).toBe(false)
    })

    it('expect (letters) to return a string, not an array of letters', () => {
        const parsing = C.letters()
            .thenLeft(F.eos())
            .single()
            .parse(Stream.ofChars('someLetters'), 0)
        expect(parsing.value).toBe('someLetters')
    })

    it('expect (string) to be accepted', () => {
        expect(
            C.string('Hello').parse(Stream.ofChars('Hello'), 0).isAccepted(),
        ).toBe(true)
    })

    it('expect (string) to be rejected', () => {
        expect(
            C.string('hello').parse(Stream.ofChars('hell'), 0).isAccepted(),
        ).toBe(false)
    })

    it('test stringIn', () => {
        let line = Stream.ofChars('James Bond')
        const combinator = C.stringIn(['The', 'James', 'Bond', 'series'])
        const value = combinator.parse(line).value
        expect(typeof value).toBe('string')
        expect(value).toBe('James')
    })

    it('test stringIn Similar', () => {
        let line = Stream.ofChars('Jack James Jane')
        const combinator = C.stringIn(['Jamie', 'Jacko', 'Jack'])
        const parsing = combinator.parse(line)
        const value = parsing.value
        expect(typeof value).toBe('string')
        expect(value).toBe('Jack')
        expect(parsing.offset).toBe('Jack'.length)
    })

    it('test stringIn one string sidecase', () => {
        let line = Stream.ofChars('James')
        const combinator = C.stringIn(['James'])
        const value = combinator.parse(line).value
        expect(typeof value).toBe('string')
        expect(value).toBe('James')
    })

    it('test stringIn empty sidecase', () => {
        let line = Stream.ofChars('James')
        const combinator = C.stringIn([]).then(F.eos())
        const parsing = combinator.parse(line)
        expect(parsing.isAccepted()).toBe(false)
    })

    it('test stringIn empty accept nothing sidecase', () => {
        let line = Stream.ofChars('')
        const combinator = C.stringIn([]).then(F.eos())
        const parsing = combinator.parse(line)
        expect(parsing.isAccepted()).toBe(true)
    })

    it('expect (notString) to be accepted', () => {
        expect(
            C.notString('**').parse(Stream.ofChars('hello'), 0).isAccepted(),
        ).toBe(true)
    })

    it('expect (notString) to be h', () => {
        expect(C.notString('**').parse(Stream.ofChars('hello'), 0).value).toBe(
            'h',
        )
    })

    it('expect (notString) to be rejected', () => {
        expect(
            C.notString('**').parse(Stream.ofChars('**hello'), 0).isAccepted(),
        ).toBe(false)
    })

    it('expect accent to be accepted', () => {
        expect(C.utf8Letter().parse(Stream.ofChars('é'), 0).isAccepted()).toBe(
            true,
        )
    })

    it('expect cyriliq to be accepted', () => {
        expect(C.utf8Letter().parse(Stream.ofChars('Б'), 0).isAccepted()).toBe(
            true,
        )
        expect(C.utf8Letter().parse(Stream.ofChars('б'), 0).isAccepted()).toBe(
            true,
        )
    })

    it('expect dash to be rejected', () => {
        expect(C.utf8Letter().parse(Stream.ofChars('-'), 0).isAccepted()).toBe(
            false,
        )
    })

    it('expect "nothing" to be rejected', () => {
        expect(C.utf8Letter().parse(Stream.ofChars(''), 0).isAccepted()).toBe(
            false,
        )
    })

    it('expect emoji to be accepted', () => {
        expect(
            C.emoji().then(F.eos()).parse(Stream.ofChars('б'), 0).isAccepted(),
        ).toBe(false)
        expect(
            C.emoji().then(F.eos()).parse(Stream.ofChars('a'), 0).isAccepted(),
        ).toBe(false)
        expect(
            C.emoji()
                .then(F.eos())
                .parse(Stream.ofChars('🐵🐵✈️'), 0)
                .isAccepted(),
        ).toBe(true)
        expect(
            C.emoji().then(F.eos()).parse(Stream.ofChars('✈️'), 0).isAccepted(),
        ).toBe(true)
        expect(
            C.emoji().then(F.eos()).parse(Stream.ofChars('🥪')).isAccepted(),
        ).toBe(true)
    })

    it('expect subString to works', () => {
        let stream = Stream.ofChars('James Bond')
        let parser = C.subString(6).then(C.string('Bond'))
        const response = parser.parse(stream)
        expect(response.value.array()).toEqual(['James ', 'Bond'])
        expect(response.isEos()).toBe(true)
    })
})



================================================
FILE: ingest/test/parsec/f-layer-test.spec.js
================================================
import { describe, it, expect } from 'vitest'
import Stream from '../../lib/stream/index'
import { F, C } from '../../lib/core/index'

describe('F Layer Tests', () => {
    it('expect F.layer(parser) to work as parser with backtrak on success', () => {
        const parser = C.char('a').thenEos()
        const successInput = 'a'
        const failInput = 'b'

        const layer = F.layer(parser)

        let response = layer.parse(Stream.ofChars(successInput))

        expect(response.isAccepted()).toBe(true)
        expect(response.offset).toBe(0)

        response = layer.parse(Stream.ofChars(failInput))

        expect(response.isAccepted()).toBe(false)
        expect(response.offset).toBe(0)
    })

    it('expect F.layer(parser).and(other) to succeed', () => {
        const first = C.char('a')
            .then(C.char('a'))
            .thenEos()
            .array()
            .map((r) => r.length)
        const second = C.string('aa').thenEos()
        const successInput = 'aa'
        const layer = F.layer(first).and(second).and(second).array()
        let response = layer.parse(Stream.ofChars(successInput))

        expect(response.isAccepted()).toBe(true)
        expect(response.value).toEqual([2, 'aa', 'aa'])
        expect(response.offset).toBe(2)
    })

    it('expect F.layer(first).and(second).and(third) to be associative', () => {
        const first = C.char('a')
            .then(C.char('a'))
            .thenEos()
            .array()
            .map((r) => r.length)
        const second = C.char('a')
            .then(C.char('a'))
            .thenEos()
            .array()
            .map((r) => r.join('-'))
        const third = C.string('aa').thenEos()
        const input = 'aa'
        const layer = F.layer(first).and(second).and(third).array()
        let response = layer.parse(Stream.ofChars(input))

        expect(response.isAccepted()).toBe(true)
        expect(response.value).toEqual([2, 'a-a', 'aa'])
        expect(response.offset).toBe(2)
    })

    it('expect F.layer(parser).and(other) to fail with second', () => {
        const first = C.char('a')
            .then(C.char('a'))
            .array()
            .thenEos()
            .map((r) => r.length)
        const second = C.string('aaFAIL').thenEos()
        const successInput = 'aa'
        const layer = F.layer(first).and(second).array()
        let response = layer.parse(Stream.ofChars(successInput))

        expect(response.isAccepted()).toBe(false)
        expect(response.offset).toBe(0)
        expect(response.value).toBeUndefined()
    })

    it('expect F.layer(parser).and(other) to fail with first', () => {
        const first = C.char('a')
            .then(C.char('a'))
            .thenEos()
            .map((r) => r.length)
        const second = C.string('aaSUCCESS').thenEos()
        const successInput = 'aaSUCCESS'
        const layer = F.layer(first).and(second)
        let response = layer.parse(Stream.ofChars(successInput))

        expect(response.isAccepted()).toBe(false)
        expect(response.offset).toBe(2)
        expect(response.value).toBeUndefined()
    })

    it('expect F.layer(parser).and(other) to not move on the second after first fails', () => {
        const first = C.char('a')
            .then(C.char('a'))
            .thenEos()
            .map((r) => r.length)
        let found = false
        const second = C.string('aaSUCCESS')
            .thenEos()
            .map((x) => {
                found = true
                return x
            })
        const successInput = 'aaSUCCESS'
        const layer = F.layer(first).and(second)
        let response = layer.parse(Stream.ofChars(successInput))

        expect(response.isAccepted()).toBe(false)
        expect(response.offset).toBe(2)
        expect(found).toBe(false)
    })
})



================================================
FILE: ingest/test/parsec/flow-bundle-test.spec.js
================================================
import { describe, it, expect } from 'vitest'
import Stream from '../../lib/stream/index'
import { F, C } from '../../lib/core/index'
import { GenLex } from '../../lib'

function testParser(parser, string) {
    let stream = Stream.ofChars(string)
    let parsing = parser.parse(stream)
    return parsing
}

describe('Flow Bundle Tests', () => {
    it('subStream is ok on string stream', () => {
        const text = 'Hello World'
        const parser = F.subStream(6).then(C.string('World'))
        const response = parser.parse(Stream.ofChars(text))

        expect(response.isAccepted()).toBe(true)
        expect(response.value.size()).toBe(7)
    })

    it('subStream is ok on genlex stream', () => {
        const genlex = new GenLex()
        genlex.setSeparatorsParser(F.not(C.charIn('+-<>[],.')))
        genlex.keywords(['+', '-', '<', '>', '[', ']', ',', '.'])
        const grammar = F.subStream(4).drop().then(F.any().rep())
        const parser = genlex.use(grammar)
        const text = '++++ and then >>'
        const response = parser.parse(Stream.ofChars(text))

        expect(response.isAccepted()).toBe(true)
        expect(response.value.size()).toBe(2)
    })

    it('not parser should not eat offset', () => {
        const text = 'this is a line'
        const line = text + '\n'
        const eol = C.char('\n')
        const parser = F.not(eol).rep()

        let response = parser.parse(Stream.ofChars(line))
        expect(response.isAccepted()).toBe(true)
        expect(response.offset).toBe(text.length)

        const withParser = F.not(eol).rep().then(eol)
        response = withParser.parse(Stream.ofChars(line))
        expect(response.isAccepted()).toBe(true)
        expect(response.offset).toBe(line.length)
    })

    it('expect flatten result to be ok', () => {
        const string = 'foobar'
        const parser = C.char('f')
            .then(C.char('o'))
            .then(C.char('o'))
            .then(C.string('bar'))
            .array()
        const parsing = testParser(parser, string)
        expect(parsing.value).toEqual(['f', 'o', 'o', 'bar'])
    })

    it('expect returns to be ok when empty', () => {
        const string = 'some'
        const parser = F.any().rep().then(F.eos()).returns([])
        const parsing = testParser(parser, string)
        expect(parsing.isAccepted()).toBe(true)
        expect(parsing.value).toEqual([])
    })

    it('expect startWith to start', () => {
        const string = ' world'
        const object = 'hello'
        const parser = F.startWith(object)
            .then(C.string(' world'))
            .then(F.eos().drop())
        const parsing = testParser(parser, string)
        expect(parsing.isAccepted()).toBe(true)
        expect(parsing.value.join('')).toBe('hello world')
    })

    it('test moveUntilFast string', () => {
        const line = Stream.ofChars('soXYZso')
        const combinator = F.moveUntil('XYZ')
        const parser = combinator.parse(line)
        expect(parser.value).toBe('so')
        expect(parser.offset).toBe(2)
    })

    it('test moveUntilFast string with include', () => {
        const line = Stream.ofChars('soXYZso')
        const combinator = F.moveUntil('XYZ', true)
        const parser = combinator.parse(line)
        expect(parser.value).toBe('soXYZ')
        expect(parser.offset).toBe(5)
    })

    it('test moveUntilFast string with continuation', () => {
        const document = 'start-detect-XYZ-continues'
        const line = Stream.ofChars(document)
        const start = C.string('start-')
        const combinator = start
            .drop()
            .then(F.moveUntil('XYZ'))
            .then(C.string('XYZ-continues').drop())
            .single()
        const parser = combinator.parse(line)
        expect(parser.value).toBe('detect-')
        expect(parser.offset).toBe(document.length)
    })

    it('test moveUntilFast array of string with continuation', () => {
        const document = 'start-detect-XYZ-continues'
        const line = Stream.ofChars(document)
        const start = C.string('start-')
        const combinator = start
            .drop()
            .then(F.moveUntil(['ABC', 'ZE', 'XYZ']))
            .then(C.string('XYZ-continues').drop())
            .single()
        const parsing = combinator.parse(line)
        expect(parsing.value).toBe('detect-')
        expect(parsing.offset).toBe(document.length)
    })

    it('test moveUntilFast array of string with include', () => {
        const document = 'start-detect-XYZ-continues'
        const line = Stream.ofChars(document)
        const start = C.string('start-')
        const combinator = start
            .drop()
            .then(F.moveUntil(['ABC', 'ZE', 'XYZ'], true))
            .then(C.string('-continues').drop())
            .single()
        const parsing = combinator.parse(line)
        expect(parsing.isAccepted()).toBe(true)
        expect(parsing.value).toBe('detect-XYZ')
        expect(parsing.offset).toBe(document.length)
    })

    it('test moveUntilFast string fails', () => {
        const document = 'start-detect-XYZ-continues'
        const line = Stream.ofChars(document)
        const start = C.string('start-')
        const combinator = start
            .drop()
            .then(F.moveUntil('EEE'))
            .then(C.string('XYZ-continues').drop())
        const parsing = combinator.parse(line)
        expect(parsing.isAccepted()).toBe(false)
    })

    it('test moveUntilFast array of string fails', () => {
        const document = 'start-detect-XYZ-continues'
        const line = Stream.ofChars(document)
        const start = C.string('start-')
        const combinator = start
            .drop()
            .then(F.moveUntil(['ABC', 'ZE', 'EEE']))
            .then(C.string('XYZ-continues').drop())
        const parsing = combinator.parse(line)
        expect(parsing.isAccepted()).toBe(false)
    })

    it('test moveUntilFast fails if array stream', () => {
        const document = ['More', 'XYZ']
        const line = Stream.ofArrays(document)
        const combinator = F.moveUntil(['ABC', 'ZE', 'XYZ'])
        expect(() => combinator.parse(line)).toThrow(
            'Input source must be a String',
        )
    })

    it('test moveUntilFastString fails if array stream', () => {
        const document = ['More', 'XYZ']
        const line = Stream.ofArrays(document)
        const combinator = F.moveUntil('XYZ')
        expect(() => combinator.parse(line)).toThrow(
            'Input source must be a String',
        )
    })

    it('test moveUntil', () => {
        const line = Stream.ofChars('I write until James appears')
        const combinator = F.moveUntil(C.string('James'))
            .then(F.any().drop())
            .single()
        const value = combinator.parse(line).value
        expect(value).toBe('I write until ')
    })

    it('test moveUntil parser, with include', () => {
        const line = Stream.ofChars('I write until James appears')
        const combinator = F.moveUntil(C.string('James'), true)
            .then(F.any().rep().drop())
            .single()
        const parsing = combinator.parse(line)
        const value = parsing.value
        expect(parsing.isAccepted()).toBe(true)
        expect(value).toBe('I write until James')
        expect(parsing.offset).toBe(line.source.length)
    })

    it('test moveUntil parser, with include and structure', () => {
        const line = Stream.ofChars('I write until James appears')
        const combinator = F.moveUntil(
            C.string('James').map((james) => ({
                structure: james,
            })),
            true,
        )
            .then(F.any().rep().drop())
            .single()
        const parsing = combinator.parse(line)
        const value = parsing.value
        expect(parsing.isAccepted()).toBe(true)
        expect(value).not.toBe('I write until James')
        expect(parsing.offset).toBe(line.source.length)
    })

    it('test moveUntil parser, with eos, not including', () => {
        const line = Stream.ofChars('I write until the end')
        const combinator = F.moveUntil(C.string('end'), false)
        const parsing = combinator.parse(line)
        const value = parsing.value
        expect(parsing.isAccepted()).toBe(true)
        expect(value).toBe('I write until the ')
        expect(parsing.offset).toBe('I write until the '.length)
    })

    it('test moveUntil parser, with eos, including', () => {
        const line = Stream.ofChars('I write until James appears')
        const combinator = F.moveUntil(C.string('appears'), true)
        const parsing = combinator.parse(line)
        const value = parsing.value
        expect(parsing.isAccepted()).toBe(true)
        expect(value).toBe('I write until James appears')
        expect(parsing.offset).toBe(line.source.length)
    })

    it('test moveUntil Not found', () => {
        const line = Stream.ofChars('I write until James appears')
        const combinator = F.moveUntil(C.string('Indiana'))
            .then(C.string('I'))
            .then(F.any().drop())
        const accepted = combinator.parse(line).isAccepted()
        expect(accepted).toBe(false)
    })

    it('test moveUntil found with failing parser', () => {
        const line = Stream.ofChars('I write until James Bond appears')
        const combinator = F.moveUntil(C.string('James')).then(
            F.dropTo(F.eos()),
        )
        const accepted = combinator.parse(line).isAccepted()
        expect(accepted).toBe(false)
    })

    it('test dropTo with string', () => {
        const line = Stream.ofChars('I write until James Bond appears')
        const combinator = F.dropTo('James')
            .then(C.string(' Bond appears'))
            .then(F.eos())
        const accepted = combinator.parse(line).isAccepted()
        expect(accepted).toBe(true)
    })

    it('test dropTo with string fail', () => {
        const line = Stream.ofChars('I write until James Bond appears')
        const combinator = F.dropTo('James')
            .then(C.string(' Bond appears'))
            .then(F.eos())
        const accepted = combinator.parse(line).isAccepted()
        expect(accepted).toBe(true)
    })

    it('test dropTo with parser', () => {
        const line = Stream.ofChars('I write until James Bond appears')
        const combinator = F.dropTo(C.string('James'))
            .then(C.string(' Bond appears'))
            .then(F.eos())
        const accepted = combinator.parse(line).isAccepted()
        expect(accepted).toBe(true)
    })

    it('test moveUntil found with more parsers', () => {
        const line = Stream.ofChars('I write until James Bond appears')
        const combinator = F.moveUntil(C.string('James'))
            .then(F.dropTo('appears'))
            .then(F.eos().drop())
            .single()
        const value = combinator.parse(line).value
        expect(value).toBe('I write until ')
    })

    it('lazy with a class', () => {
        class SomeLazyParser {
            constructor(char) {
                this.char = char
            }

            first() {
                return C.char(this.char).then(
                    this.second()
                        .opt()
                        .map((opt) => opt.orElse('')),
                )
            }

            second() {
                return C.char('b').then(F.lazy(this.first, ['a'], this))
            }
        }

        const line = Stream.ofChars('ababa')
        const combinator = new SomeLazyParser('a').first().then(F.eos().drop())
        const value = combinator.parse(line).value
        expect(value.join('')).toBe('ababa')
    })
})



================================================
FILE: ingest/test/parsec/flow-move-until.spec.js
================================================
import { describe, it, expect } from 'vitest'
import Stream from '../../lib/stream/index'
import { F, C } from '../../lib/core/index'

describe('moveUntil do not return a TupleParser', () => {
    it('test moveUntil returning a string when stopping at a string', () => {
        const document = 'aaXYZb'
        const line = Stream.ofChars(document)
        const combinator = F.moveUntil('XYZ')
        const parser = combinator.parse(line)
        expect(parser.value).toBe('aa')
    })

    it('test moveUntil returning a string when stopping at parser', () => {
        const document = 'aaXYZb'
        const line = Stream.ofChars(document)
        const combinator = F.moveUntil(C.string('XYZ'))
        const parser = combinator.parse(line)
        expect(parser.value).toBe('aa')
    })
})



================================================
FILE: ingest/test/parsec/flow-regex-flags.spec.js
================================================
import { describe, it, expect } from 'vitest'
import Stream from '../../lib/stream/index'
import { F } from '../../lib/core/index'

describe('F.regex – behaviour of individual RegExp flags', () => {
    /* ───────────────────────────── i : ignore-case ─────────────────────────── */
    it('i flag → matches despite case difference / no-i flag → fails', () => {
        // with i
        let stream = Stream.ofChars('ABC')
        let parsing = F.regex(/abc/i).parse(stream)
        expect(parsing.isAccepted()).toBe(true)
        expect(parsing.value).toBe('ABC')
        expect(parsing.offset).toBe(3)

        // without i
        stream = Stream.ofChars('ABC')
        parsing = F.regex(/abc/).parse(stream)
        expect(parsing.isAccepted()).toBe(false)
        expect(parsing.offset).toBe(0)
    })

    /* ───────────────────────────── s : dotAll ──────────────────────────────── */
    it('s flag → dot matches newline / no-s flag → fails', () => {
        // with s
        let stream = Stream.ofChars('a\nb')
        let parsing = F.regex(/a.b/s).parse(stream)
        expect(parsing.isAccepted()).toBe(true)
        expect(parsing.value).toBe('a\nb')
        expect(parsing.offset).toBe(3)

        // without s
        stream = Stream.ofChars('a\nb')
        parsing = F.regex(/a.b/).parse(stream)
        expect(parsing.isAccepted()).toBe(false)
    })

    /* ───────────────────────────── m : multiline anchors ───────────────────── */
    it('m flag → ^/$ see line breaks / no-m flag → fails mid-string', () => {
        const src = 'foo\nbar' // 'bar' starts at offset 4

        // with m
        let stream = Stream.ofChars(src)
        let parsing = F.regex(/^bar$/m).parse(stream, 4)
        expect(parsing.isAccepted()).toBe(true)
        expect(parsing.value).toBe('bar')
        expect(parsing.offset).toBe(7) // 4 + 3

        // without m
        stream = Stream.ofChars(src)
        parsing = F.regex(/^bar$/).parse(stream, 4)
        expect(parsing.isAccepted()).toBe(false)
    })

    /* ───────────────────────────── u : unicode escapes ─────────────────────── */
    it('u flag → \\u{…} escape recognised / no-u flag → fails', () => {
        const smile = '😀' // U+1F600 (surrogate pair)

        // with u
        let stream = Stream.ofChars(smile)
        let parsing = F.regex(/\u{1F600}/u).parse(stream)
        expect(parsing.isAccepted()).toBe(true)
        expect(parsing.value).toBe(smile)
        expect(parsing.offset).toBe(smile.length) // 2 code units in UTF-16

        // without u
        stream = Stream.ofChars(smile)
        parsing = F.regex(/\u{1F600}/).parse(stream)
        expect(parsing.isAccepted()).toBe(false)
    })

    it('matches only when the cursor is exactly on the pattern', () => {
        const stickyB = /b/y

        // cursor on the b  → accepted
        let stream = Stream.ofChars('ab')
        let parsing = F.regex(stickyB).parse(stream, 1) // start at index 1
        expect(parsing.isAccepted()).toBe(true)
        expect(parsing.value).toBe('b')
        expect(parsing.offset).toBe(2) // consumed one char

        // cursor before the b → rejected (sticky prevents look-ahead)
        stream = Stream.ofChars('ab')
        parsing = F.regex(stickyB).parse(stream, 0) // start at index 0
        expect(parsing.isAccepted()).toBe(false)
        expect(parsing.offset).toBe(0) // untouched on failure
    })
})



================================================
FILE: ingest/test/parsec/flow-regex.spec.js
================================================
import { describe, it, expect } from 'vitest'
import Stream from '../../lib/stream/index'
import { F, C } from '../../lib/core/index'

describe('Chars Bundle Tests', () => {
    it('accepts a single character', () => {
        const stream = Stream.ofChars('a')
        const parsing = F.regex(/[a-z]/).parse(stream)
        expect(parsing.isAccepted()).toBe(true)
        expect(parsing.value).toBe('a')
        expect(parsing.offset).toBe(1)
    })

    it('consumes when accepting a single character', () => {
        const stream = Stream.ofChars('aa')
        const parsing = F.regex(/[a-z]/).parse(stream)
        expect(parsing.isAccepted()).toBe(true)
        expect(parsing.value).toBe('a')
        expect(parsing.offset).toBe(1)
    })

    it('do not consumes when rejecting a single character', () => {
        const stream = Stream.ofChars('0a')
        const parsing = F.regex(/[a-z]/).parse(stream)
        expect(parsing.isAccepted()).toBe(false)
        expect(parsing.value).toBeUndefined()
        expect(parsing.offset).toBe(0)
    })

    it('accepts multiple characters', () => {
        const stream = Stream.ofChars('abc')
        const parsing = F.regex(/[a-z]+/).parse(stream)
        expect(parsing.isAccepted()).toBe(true)
        expect(parsing.value).toBe('abc')
        expect(parsing.offset).toBe(3)
    })

    it('moves as long as possible eating multiple characters', () => {
        const stream = Stream.ofChars('abc0')
        const parsing = F.regex(/[a-z]+/).parse(stream)
        expect(parsing.isAccepted()).toBe(true)
        expect(parsing.value).toBe('abc')
        expect(parsing.offset).toBe(3)
    })

    it('star is accepted even rejects when no characters match', () => {
        const stream = Stream.ofChars('0')
        const parsing = F.regex(/[a-z]*/).parse(stream)
        expect(parsing.isAccepted()).toBe(true)
        expect(parsing.value).not.toBeUndefined() // empty but accepted!
        expect(parsing.value).toBe('')
        expect(parsing.offset).toBe(0)
    })

    it('accept a identifier building', () => {
        const stream = Stream.ofChars('myUser = "John";')
        const parsing = F.regex(/[a-zA-Z_][a-zA-Z0-9_]*/).parse(stream)
        expect(parsing.isAccepted()).toBe(true)
        expect(parsing.value).toBe('myUser')
        expect(parsing.offset).toBe(6)
    })

    it('rejects a identifier building', () => {
        const stream = Stream.ofChars('0myUser = "John";')
        const parsing = F.regex(/[a-zA-Z_][a-zA-Z0-9_]*/).parse(stream)
        expect(parsing.isAccepted()).toBe(false)
        expect(parsing.value).toBeUndefined()
        expect(parsing.offset).toBe(0)
    })

    it('goes in a then flow', () => {
        const expression = 'myUser :=otherUser'
        const stream = Stream.ofChars(expression)
        const parsing = assignParser().parse(stream)
        expect(parsing.isAccepted()).toBeTruthy()
        expect(parsing.offset).toBe(expression.length)
    })

    it('stops in a then flow', () => {
        const expression = 'myUser := 0otherUser'

        const stream = Stream.ofChars(expression)
        const parsing = assignParser().parse(stream)
        expect(parsing.isAccepted()).toBeFalsy()
        expect(parsing.value).toBeUndefined()
        expect(parsing.offset).toBe(expression.indexOf('0'))
    })

    it('consumes the number but not the unit using look-ahead', () => {
        const pixelRe = /\d+(?=px)/ // look-ahead keeps "px" in input
        const stream = Stream.ofChars('20px')
        const parsing = F.regex(pixelRe).parse(stream)

        expect(parsing.isAccepted()).toBe(true)
        expect(parsing.value).toBe('20')
        expect(parsing.offset).toBe(2) // only “20” eaten
    })

    it('accepts a 3- or 6-digit CSS hex colour', () => {
        //   #RGB      |        #RRGGBB
        const colourRe = /#[0-9a-fA-F]{3}(?:[0-9a-fA-F]{3})?/

        const stream = Stream.ofChars('#abcDEF;')
        const parsing = F.regex(colourRe).parse(stream)

        expect(parsing.isAccepted()).toBe(true)
        expect(parsing.value).toBe('#abcDEF')
        expect(parsing.offset).toBe(7) // consumed exactly the colour
    })

    it('accepts a quoted string whose end quote matches the start', () => {
        const quotedRe = /(['"])(.*?)\1/ // "Hello", 'Hello', etc.
        const stream = Stream.ofChars('"Hello World" rest')
        const parsing = F.regex(quotedRe).parse(stream)

        expect(parsing.isAccepted()).toBe(true)
        expect(parsing.value).toBe('"Hello World"')
        expect(parsing.offset).toBe(13) // length of `"Hello World"`
    })

    it('rejects a quoted string with wrong back reference', () => {
        const quotedRe = /(['"])(.*?)\1/ // "Hello" ok, but not "Hello'
        const stream = Stream.ofChars(`"Hello World' rest`)
        const parsing = F.regex(quotedRe).parse(stream)

        expect(parsing.isAccepted()).toBe(false)
        expect(parsing.value).toBeUndefined()
        expect(parsing.offset).toBe(0) // length of `"Hello World"`
    })
})

function assignParser() {
    const identifier = F.regex(/[a-zA-Z_][a-zA-Z0-9_]*/)
    const space = F.regex(/\s+/)
    const assign = C.string(':=')
    return identifier
        .then(space.optrep().drop())
        .then(assign)
        .then(space.optrep().drop())
        .then(identifier)
}



================================================
FILE: ingest/test/parsec/flow-try-or.spec.js
================================================
import { describe, it, expect } from 'vitest'
import { NEUTRAL } from '../../lib/index.js'
import Stream from '../../lib/stream/index'
import { C, F } from '../../lib/core/index'

describe('combining F.try() and p.or()', () => {
    it('works straightforward with a single or()', () => {
        const endLiner = C.char('\n').or(F.eos())
        const parser = F.moveUntil(endLiner.drop())

        const document = 'hello world\n'
        const stream = Stream.ofChars(document)
        const parsing = parser.parse(stream)
        expect(parsing.value).toBe('hello world')
        expect(parsing.offset).toBe(document.length - 1)
    })

    it('eats some chars with or', () => {
        const eater = C.char('a').then(C.char('a'))
        const parser = eater.or(C.char('b'))

        const stream = Stream.ofChars('ab')
        const parsing = parser.parse(stream)
        expect(parsing.isAccepted()).toBe(false)

        // ✨ this is the point ! one 'a' is consumed when failing
        expect(parsing.offset).toBe(1)
    })

    it('avoids eating with F.try()', () => {
        const eater = C.char('a').then(C.char('a'))
        const parser = F.try(eater)

        const stream = Stream.ofChars('ab')
        const parsing = parser.parse(stream)
        expect(parsing.isAccepted()).toBe(false)

        // not consumed as expected
        expect(parsing.consumed).toBe(false)
        // ✨ fixed: despite backtracking,  'a' is consumed when failing
        expect(parsing.offset).toBe(0)
    })

    it('F.try().or() can still eat because of or', () => {
        const eater = C.char('a').then(C.char('a'))
        const secondEater = C.char('a').then(C.char('b'))
        const parser = F.try(eater).or(secondEater)

        const stream = Stream.ofChars('ac')
        const parsing = parser.parse(stream)
        expect(parsing.isAccepted()).toBe(false)

        // ✨ despite backtracking for first parser, the second will eat 'a'
        expect(parsing.offset).toBe(1)
    })

    it('F.try(x).or(F.try(y)) will not eat ', () => {
        const eater = C.char('a').then(C.char('a'))
        const secondEater = C.char('a').then(C.char('b'))
        const parser = F.try(eater).or(F.try(secondEater))

        const stream = Stream.ofChars('ac')
        const parsing = parser.parse(stream)
        expect(parsing.isAccepted()).toBe(false)

        // ✨ With full backtracking, nothing is eaten
        expect(parsing.offset).toBe(0)
    })

    it('Full backtracking works at index !=0 ', () => {
        const start = C.string('====')
        const eater = C.char('a').then(C.char('a'))
        const parser = start.drop().then(F.try(eater))

        const stream = Stream.ofChars('====ac')
        const parsing = parser.parse(stream)
        expect(parsing.isAccepted()).toBe(false)

        // ✨ despite backtracking for the first parser, the second will eat 'a'
        expect(parsing.offset).toBe(4)
    })

    it('parses with backtrack using F.all()', () => {
        const eater = C.char('a').then(C.char('a'))
        const secondEater = C.char('a').then(C.char('b'))
        const thirdEater = C.char('a').then(C.char('c'))
        const parser = F.tryAll([eater, secondEater, thirdEater])

        const stream = Stream.ofChars('ab')
        const parsing = parser.parse(stream)
        expect(parsing.isAccepted()).toBe(true)
        expect(parsing.offset).toBe(2)
    })

    it('can fail with F.all(), not eating chars', () => {
        const eater = C.char('a').then(C.char('a'))
        const secondEater = C.char('a').then(C.char('c'))
        const thirdEater = C.char('a').then(C.char('d'))
        const parser = F.tryAll([eater, secondEater, thirdEater])

        const stream = Stream.ofChars('ab')
        const parsing = parser.parse(stream)
        expect(parsing.isAccepted()).toBe(false)
        expect(parsing.offset).toBe(0)
    })

    it('use tryAll with empty array, mapping empty tuple', () => {
        const parser = F.tryAll([])

        const stream = Stream.ofChars('ab')
        const parsing = parser.parse(stream)
        expect(parsing.isAccepted()).toBe(true)
        expect(parsing.offset).toBe(0)
        expect(parsing.value).toBe(NEUTRAL)
    })

    it('use tryAll with empty array in a series', () => {
        const parser = F.tryAll([])
            .then(C.char('a'))
            .then(F.tryAll([]))
            .then(C.char('b'))
            .join()

        const stream = Stream.ofChars('ab')
        const parsing = parser.parse(stream)
        expect(parsing.isAccepted()).toBe(true)
        expect(parsing.offset).toBe(2)
        expect(parsing.value).toBe('ab')
    })
})



================================================
FILE: ingest/test/parsec/number-bundle-test.spec.js
================================================
import { describe, it, expect } from 'vitest'
import stream from '../../lib/stream/index'
import { N } from '../../lib/core/index'

function testParser(parser, string) {
    let myStream = stream.ofChars(string)
    let parsing = parser.parse(myStream)
    return parsing
}

describe('Number Bundle Tests', () => {
    it('expect N.integer() to be ok', () => {
        const string = '007'
        const parser = N.integer()
        const parsing = testParser(parser, string)
        expect(parsing.value).toBe(7)
    })

    it('expect N.integer() with sign to be ok', () => {
        const string = '-007'
        const parser = N.integer()
        const parsing = testParser(parser, string)
        expect(parsing.value).toBe(-7)
    })

    it('expect number without sign to be ok', () => {
        const string = '007.12'
        const parser = N.number()
        const parsing = testParser(parser, string)
        expect(parsing.value).toBe(7.12)
    })

    it('expect many digits to be joined and to be a number', () => {
        const string = '007'
        const parser = N.digits()
        const parsing = testParser(parser, string)
        expect(typeof parsing.value).toBe('number')
        expect(parsing.value).toBe(7)
    })
})



================================================
FILE: ingest/test/parsec/parser-tuple-map.spec.js
================================================
import { describe, it, expect } from 'vitest'
import { C, N } from '../../lib/index.js'

describe('Parser tupleMap Tests', () => {
    it('tupleMap applies function to each element of tuple', () => {
        const parser = C.char('a')
            .then(C.char('b'))
            .then(C.char('c'))
            .tupleMap((char) => char.toUpperCase())

        const result = parser.val('abc')
        expect(result.array()).toEqual(['A', 'B', 'C'])
    })

    it('tupleMap returns new Tuple instance', () => {
        const originalParser = C.char('a').then(C.char('b'))
        const mappedParser = originalParser.tupleMap((char) => char)

        const original = originalParser.val('ab')
        const mapped = mappedParser.val('ab')

        expect(mapped).not.toBe(original)
        expect(mapped).toBeInstanceOf(original.constructor)
    })

    it('tupleMap on empty tuple returns empty tuple', () => {
        const parser = C.char('a')
            .drop()
            .then(C.char('b').drop())
            .tupleMap((x) => x * 2)
        const result = parser.val('ab')

        expect(result.isEmpty()).toBe(true)
        expect(result.array()).toEqual([])
    })

    it('tupleMap with number transformation', () => {
        const parser = N.digit()
            .then(N.digit())
            .then(N.digit())
            .tupleMap((digit) => digit * 2)

        const result = parser.val('123')
        expect(result.array()).toEqual([2, 4, 6])
    })

    it('tupleMap with string transformation', () => {
        const parser = C.char('a')
            .then(C.char('b'))
            .then(C.char('c'))
            .tupleMap((char) => `char_${char}`)

        const result = parser.val('abc')
        expect(result.array()).toEqual(['char_a', 'char_b', 'char_c'])
    })

    it('tupleMap with object transformation', () => {
        const parser = N.digit()
            .then(N.digit())
            .tupleMap((digit) => ({ value: digit, squared: digit * digit }))

        const result = parser.val('23')
        expect(result.array()).toEqual([
            { value: 2, squared: 4 },
            { value: 3, squared: 9 },
        ])
    })

    it('tupleMap preserves original parser result unchanged', () => {
        const parser = C.char('a').then(C.char('b'))
        const originalResult = parser.val('ab')
        const originalArray = [...originalResult.value]

        parser.tupleMap((char) => char.toUpperCase()).val('ab')

        expect(originalResult.value).toEqual(originalArray)
    })

    it('tupleMap with complex parser chain', () => {
        const parser = C.char('a')
            .then(C.char('b').drop())
            .then(C.char('c'))
            .tupleMap((char) => char.toUpperCase())

        const result = parser.val('abc')
        expect(result.array()).toEqual(['A', 'C']) // 'b' is dropped
    })

    it('tupleMap with repetition parser', () => {
        const parser = C.char('a')
            .rep()
            .tupleMap((char) => char.toUpperCase())

        const result = parser.val('aaa')
        expect(result.array()).toEqual(['A', 'A', 'A'])
    })

    it('tupleMap with optional repetition parser', () => {
        const parser = C.char('a')
            .optrep()
            .tupleMap((char) => char.toUpperCase())

        const result = parser.val('aa')
        expect(result.array()).toEqual(['A', 'A'])
    })

    it('tupleMap with empty optional repetition', () => {
        const parser = C.char('a')
            .optrep()
            .tupleMap((char) => char.toUpperCase())

        const result = parser.val('b')
        expect(result.isEmpty()).toBe(true)
    })

    it('tupleMap throws error when called on non-tuple parser', () => {
        const parser = C.char('a').tupleMap((char) => char.toUpperCase())

        expect(() => parser.val('a')).toThrow(
            'Calling tupleMap on a non tuple object',
        )
    })

    it('tupleMap with single element tuple', () => {
        const parser = C.char('a').tupleMap((char) => char.toUpperCase())

        expect(() => parser.val('a')).toThrow(
            'Calling tupleMap on a non tuple object',
        )
    })

    it('tupleMap with mixed content tuple', () => {
        const parser = C.char('a')
            .then(N.digit())
            .then(C.char('c'))
            .tupleMap((item) =>
                typeof item === 'string' ? item.toUpperCase() : item * 2,
            )

        const result = parser.val('a2c')
        expect(result.array()).toEqual(['A', 4, 'C'])
    })

    it('tupleMap can be chained', () => {
        const parser = C.char('a')
            .then(C.char('b'))
            .then(C.char('c'))
            .tupleMap((char) => char.toUpperCase())
            .tupleMap((char) => char.toLowerCase())

        const result = parser.val('abc')
        expect(result.array()).toEqual(['a', 'b', 'c'])
    })

    it('tupleMap with filter-like behavior', () => {
        const parser = C.char('a')
            .then(C.char('b'))
            .then(C.char('c'))
            .tupleMap((char) => (char === 'b' ? 'B' : char))

        const result = parser.val('abc')
        expect(result.array()).toEqual(['a', 'B', 'c'])
    })

    it('tupleMap works with nested tuples', () => {
        const innerParser = C.char('x').then(C.char('y'))
        const parser = innerParser.then(innerParser).tupleMap((item) => {
            if (item.constructor.name === 'Tuple') {
                return item.map((char) => char.toUpperCase())
            }
            return item
        })

        const result = parser.val('xyxy')
        // The result is a flat tuple: ['x', 'y', 'x', 'y']
        expect(result.array()).toEqual(['x', 'y', 'x', 'y'])
    })

    it('tupleMap preserves tuple methods', () => {
        const parser = C.char('a')
            .then(C.char('b'))
            .then(C.char('c'))
            .tupleMap((char) => char.toUpperCase())

        const result = parser.val('abc')

        expect(result.single()).toBe('A')
        expect(result.first()).toBe('A')
        expect(result.last()).toBe('C')
        expect(result.at(1)).toBe('B')
        expect(result.join('-')).toBe('A-B-C')
    })
})



================================================
FILE: ingest/test/parsec/parser_chain_test.spec.js
================================================
import { describe, it, expect } from 'vitest'
import stream from '../../lib/stream/index'
import { F, C, N } from '../../lib/core/index'
import unit from '../../lib/data/unit'

function spaces() {
    return C.charIn(' \r\n\f\t')
        .optrep()
        .map(() => unit)
}

describe('Parser Chain Tests', () => {
    it('expect (chain) to be accepted', () => {
        const lower = C.char('x')
        const upper = F.satisfy((val) => val === 'x')
        const parser = lower.chain(upper)
        const response = parser.parse(stream.ofChars('x'))
        expect(response.isAccepted()).toBe(true)
    })

    it('expect (chain) to be rejected', () => {
        const lower = C.char('x')
        const upper = F.satisfy((val) => val === 'y')
        const parser = lower.chain(upper)
        const response = parser.parse(stream.ofChars('x'))
        expect(response.isAccepted()).toBe(false)
    })

    it('expect (chain) to be accepted and offset to have move', () => {
        const lower = C.char('x')
        const upper = F.satisfy((val) => val === 'x')
        const parser = lower.chain(upper)
        const response = parser.parse(stream.ofChars('x'))
        expect(response.offset).toBe(1)
    })

    it('expect (chain) to be accepted and offset to have move more', () => {
        const lower = C.string('xyz')
        const upper = F.satisfy((val) => val === 'xyz')
        const parser = lower.chain(upper.then(upper))
        const response = parser.parse(stream.ofChars('xyzxyz'))
        expect(response.offset).toBe(2)
    })

    it('expect (chain) to be find back the source offset', () => {
        const lower = C.string('xyz')
        const upper = F.satisfy((val) => val === 'xyz')
        const parser = lower.chain(upper.then(upper))
        const response = parser.parse(stream.ofChars('xyzxyz'))
        expect(response.input.source.offsets[response.offset]).toBe(6)
    })

    it('expect (chain) to be accepted again', () => {
        const p1 = N.number().thenLeft(C.char(' ').opt())
        const p2 = F.any()
            .then(F.any())
            .thenLeft(F.eos())
            .map(function (r) {
                return r[0] + r[1]
            })
        expect(
            p1.chain(p2).parse(stream.ofChars('12 34'), 0).isAccepted(),
        ).toBe(true)
    })

    it('expect (chain) to return 46', () => {
        const p1 = N.number().thenLeft(C.char(' ').opt())
        const p2 = F.any()
            .then(F.any())
            .thenLeft(F.eos())
            .array()
            .map(function (r) {
                return r[0] + r[1]
            })
        expect(p1.chain(p2).parse(stream.ofChars('12 34'), 0).value).toBe(46)
    })

    it('expect (chain) to add multiple numbers', () => {
        const token = N.number().then(spaces().opt().drop()).single()
        const lex = F.satisfy((number) => number > 0)
            .rep()
            .map((values) => values.array().reduce((acc, n) => acc + n, 0))

        const parsing = token.chain(lex).parse(stream.ofChars('10 12 44'), 0)

        expect(parsing.isEos()).toBe(true)
        expect(parsing.value).toBe(66)
    })

    it('expect (chain) to be not satisfied by upper level', () => {
        const token = N.number().then(spaces().opt().drop())
        const lex = F.satisfy((number) => number > 0)
            .rep()
            .map((values) => values.array().reduce((acc, n) => acc + n, 0))

        const parsing = token.chain(lex).parse(stream.ofChars('10 -12 44'), 0)

        expect(parsing.isEos()).toBe(false)
    })
})



================================================
FILE: ingest/test/parsec/parser_core_default_test.spec.js
================================================
import { describe, it, expect } from 'vitest'
import stream from '../../lib/stream/index'
import { F, C } from '../../lib/core/index'

describe('Parser Core Default Tests', () => {
    it('expect (map) to be accepted', () => {
        expect(
            C.char('a')
                .map(function (a) {
                    return a + 'b'
                })
                .parse(stream.ofChars('a'))
                .isAccepted(),
        ).toBe(true)
    })

    it('expect (map) to be rejected', () => {
        expect(
            C.char('a')
                .map(function (a) {
                    return a + 'b'
                })
                .parse(stream.ofChars('b'))
                .isAccepted(),
        ).toBe(false)
    })

    it('expect (map) to be return ab', () => {
        expect(
            C.char('a')
                .map(function (a) {
                    return a + 'b'
                })
                .parse(stream.ofChars('a')).value,
        ).toBe('ab')
    })

    it('expect (flatMap) to be accepted', () => {
        expect(
            C.char('a')
                .flatMap(function () {
                    return F.returns('b')
                })
                .parse(stream.ofChars('a'))
                .isAccepted(),
        ).toBe(true)
    })

    it('expect (flatMap) to be rejected', () => {
        expect(
            C.char('a')
                .flatMap(function () {
                    return F.returns('b')
                })
                .parse(stream.ofChars('b'))
                .isAccepted(),
        ).toBe(false)
    })

    it('expect (flatMap) to be return ab', () => {
        expect(
            C.char('a')
                .flatMap(function () {
                    return C.char('b')
                })
                .parse(stream.ofChars('ab')).value,
        ).toBe('b')
    })

    it('expect (flatMap) to be return a-b-c', () => {
        expect(
            C.char('a')
                .flatMap((aVal) =>
                    C.char('b')
                        .then(C.char('c'))
                        .map((bcVal) => aVal + '-' + bcVal.join('-')),
                )
                .parse(stream.ofChars('abc')).value,
        ).toBe('a-b-c')
    })

    it('expect (filter) to be accepted', () => {
        expect(
            C.char('a')
                .filter((a) => a === 'a')
                .parse(stream.ofChars('a'))
                .isAccepted(),
        ).toBe(true)
    })

    it('expect (filter) to be rejected', () => {
        expect(
            C.char('a')
                .filter((a) => a === 'b')
                .parse(stream.ofChars('a'))
                .isAccepted(),
        ).toBe(false)
    })

    it('expect (match) to be accepted', () => {
        expect(
            C.char('a').match('a').parse(stream.ofChars('a')).isAccepted(),
        ).toBe(true)
    })

    it('expect (match) to be rejected', () => {
        expect(
            C.char('a').match('b').parse(stream.ofChars('a')).isAccepted(),
        ).toBe(false)
    })

    it('expect (then) to be accepted', () => {
        expect(
            C.char('a')
                .then(C.char('b'))
                .parse(stream.ofChars('ab'))
                .isAccepted(),
        ).toBe(true)
    })

    it('expect (then) to be build [a,b]', () => {
        expect(
            C.char('a').then(C.char('b')).array().parse(stream.ofChars('ab'))
                .value,
        ).toEqual(['a', 'b'])
    })

    it('expect (then) left to be rejected', () => {
        expect(
            C.char('a')
                .then(C.char('b'))
                .parse(stream.ofChars('cb'))
                .isAccepted(),
        ).toBe(false)
    })

    it('expect (then) right to be rejected', () => {
        expect(
            C.char('a')
                .then(C.char('b'))
                .parse(stream.ofChars('ac'))
                .isAccepted(),
        ).toBe(false)
    })

    it('expect (then) to return [a,b]', () => {
        expect(
            C.char('a').then(C.char('b')).array().parse(stream.ofChars('ab'))
                .value,
        ).toEqual(['a', 'b'])
    })

    it('expect (thenLeft) to be accepted', () => {
        expect(
            C.char('a')
                .thenLeft(C.char('b'))
                .parse(stream.ofChars('ab'))
                .isAccepted(),
        ).toBe(true)
    })

    it('expect (thenLeft) to return a', () => {
        expect(
            C.char('a')
                .thenLeft(C.char('b'))
                .single()
                .parse(stream.ofChars('ab')).value,
        ).toBe('a')
    })

    it('expect (thenLeft) to be rejected', () => {
        expect(
            C.char('a')
                .thenLeft(C.char('b'))
                .parse(stream.ofChars('b'))
                .isAccepted(),
        ).toBe(false)
    })

    it('expect (thenRight) to be accepted', () => {
        expect(
            C.char('a')
                .thenRight(C.char('b'))
                .parse(stream.ofChars('ab'))
                .isAccepted(),
        ).toBe(true)
    })

    it('expect (thenRight) to return a', () => {
        expect(
            C.char('a')
                .thenRight(C.char('b'))
                .single()
                .parse(stream.ofChars('ab')).value,
        ).toBe('b')
    })

    it('expect (thenRight) to be rejected', () => {
        expect(
            C.char('a')
                .thenRight(C.char('b'))
                .parse(stream.ofChars('b'))
                .isAccepted(),
        ).toBe(false)
    })

    it('expect (returns) to be accepted', () => {
        expect(
            C.char('a').returns('b').parse(stream.ofChars('ab')).isAccepted(),
        ).toBe(true)
    })

    it('expect (returns) to return b', () => {
        expect(C.char('a').returns('b').parse(stream.ofChars('ab')).value).toBe(
            'b',
        )
    })

    it('expect (returns) to be rejected', () => {
        expect(
            C.char('a').returns('b').parse(stream.ofChars('b')).isAccepted(),
        ).toBe(false)
    })

    it('expect (or) to be accepted', () => {
        expect(
            C.char('a').or(C.char('b')).parse(stream.ofChars('a')).isAccepted(),
        ).toBe(true)
    })

    it('expect (or) bis to be accepted', () => {
        expect(
            C.char('a').or(C.char('b')).parse(stream.ofChars('b')).isAccepted(),
        ).toBe(true)
    })

    it('expect (or) to be rejected', () => {
        expect(
            C.char('a').or(C.char('b')).parse(stream.ofChars('c')).isAccepted(),
        ).toBe(false)
    })

    it('expect (or) LL(1) to be rejected', () => {
        expect(
            C.char('a')
                .then(C.char('b'))
                .or(C.char('a'))
                .parse(stream.ofChars('ac'))
                .isAccepted(),
        ).toBe(false)
    })

    it('expect (or) to return a', () => {
        expect(
            C.char('a').or(C.char('b')).parse(stream.ofChars('a')).value,
        ).toBe('a')
    })

    it('expect (or) to return b', () => {
        expect(
            C.char('a').or(C.char('b')).parse(stream.ofChars('b')).value,
        ).toBe('b')
    })

    it('expect (then.or) left to be rejected', () => {
        expect(
            C.char('a')
                .then(C.char('b').or(C.char('c')))
                .parse(stream.ofChars('ad'))
                .isAccepted(),
        ).toBe(false)
    })

    it('expect (then.or) left to be consumed', () => {
        expect(
            C.char('a')
                .then(C.char('b').or(C.char('c')))
                .parse(stream.ofChars('ad')).consumed,
        ).toBe(true)
    })

    it('expect (opt) some to accepted', () => {
        expect(C.char('a').opt().parse(stream.ofChars('a')).isAccepted()).toBe(
            true,
        )
    })

    it('expect (opt) some to return some a', () => {
        expect(C.char('a').opt().parse(stream.ofChars('a')).value.get()).toBe(
            'a',
        )
    })

    it('expect (opt) none to accepted', () => {
        expect(C.char('a').opt().parse(stream.ofChars('b')).isAccepted()).toBe(
            true,
        )
    })

    it('expect (opt) none to return none', () => {
        expect(
            C.char('a').opt().parse(stream.ofChars('b')).value.isPresent(),
        ).toBe(false)
    })

    it('expect (opt) to come back if fail', () => {
        expect(
            C.char('b')
                .then(C.string('aaFAIL').opt().drop())
                .then(C.string('aaab'))
                .parse(stream.ofChars('baaab'))
                .value.join(''),
        ).toBe('baaab')
    })

    it('expect (rep) to accepted', () => {
        expect(C.char('a').rep().parse(stream.ofChars('a')).isAccepted()).toBe(
            true,
        )
    })

    it('expect (rep) to rejected', () => {
        expect(C.char('a').rep().parse(stream.ofChars('b')).isAccepted()).toBe(
            false,
        )
    })

    it('expect (rep) mutiple to accepted', () => {
        expect(
            C.char('a').rep().parse(stream.ofChars('aaaabbb')).isAccepted(),
        ).toBe(true)
    })

    it('expect (rep) mutiple to return [a,a,a,a]', () => {
        expect(
            C.char('a').rep().parse(stream.ofChars('aaaabbb')).value.array(),
        ).toEqual(['a', 'a', 'a', 'a'])
    })

    it('expect (optrep) to accepted', () => {
        expect(
            C.char('a').optrep().parse(stream.ofChars('a')).isAccepted(),
        ).toBe(true)
    })

    it('expect (optrep) none to accepted', () => {
        expect(
            C.char('a').optrep().parse(stream.ofChars('b')).isAccepted(),
        ).toBe(true)
    })

    it('expect (optrep) multiple to accepted', () => {
        expect(
            C.char('a').optrep().parse(stream.ofChars('aaaabbb')).isAccepted(),
        ).toBe(true)
    })

    it('expect (optrep) multiple to return some [a,a,a,a]', () => {
        expect(
            C.char('a').optrep().parse(stream.ofChars('aaaabbb')).value.array(),
        ).toEqual(['a', 'a', 'a', 'a'])
    })

    it('expect (optrep) to return none', () => {
        expect(
            C.char('a').optrep().parse(stream.ofChars('bbb')).value.array(),
        ).toEqual([])
    })

    it('expect (optrep) to return [b,b,b]', () => {
        expect(
            C.notChar('a').optrep().parse(stream.ofChars('bbba')).value.array(),
        ).toEqual(['b', 'b', 'b'])
    })
})



================================================
FILE: ingest/test/parsec/parser_core_test.spec.js
================================================
import { describe, it, expect } from 'vitest'
import stream from '../../lib/stream/index'
import { F, C, N } from '../../lib/core/index'

describe('Parser Core Tests', () => {
    it('expect val to be a nice shortcut', () => {
        const parser = C.string('xyz')
        const val = parser.val('xyz')
        expect(val).toBe('xyz')
    })

    it('expect (map) to be accepted', () => {
        expect(
            C.char('a')
                .map(function (a) {
                    return a + 'b'
                })
                .parse(stream.ofChars('a'), 0)
                .isAccepted(),
        ).toBe(true)
    })

    it('expect (map) to be rejected', () => {
        expect(
            C.char('a')
                .map(function (a) {
                    return a + 'b'
                })
                .parse(stream.ofChars('b'), 0)
                .isAccepted(),
        ).toBe(false)
    })

    it('expect (map) to be return ab', () => {
        expect(
            C.char('a')
                .map(function (a) {
                    return a + 'b'
                })
                .parse(stream.ofChars('a'), 0).value,
        ).toBe('ab')
    })

    it('expect (map) to be return 5x8', () => {
        const st = stream.ofChars('5x8')
        const combinator = N.integer()
            .then(C.char('x').drop())
            .then(N.integer())
            .array()
            .map((values) => values[0] * values[1])

        expect(combinator.parse(st).value).toBe(40)
    })

    it('expect (flatMap) to be accepted', () => {
        expect(
            C.char('a')
                .flatMap(function () {
                    return F.returns('b')
                })
                .parse(stream.ofChars('a'), 0)
                .isAccepted(),
        ).toBe(true)
    })

    it('expect (flatMap) to be rejected', () => {
        expect(
            C.char('a')
                .flatMap(function () {
                    return F.returns('b')
                })
                .parse(stream.ofChars('b'), 0)
                .isAccepted(),
        ).toBe(false)
    })

    it('expect (flatMap) to be return ab', () => {
        expect(
            C.char('a')
                .flatMap(function () {
                    return C.char('b')
                })
                .parse(stream.ofChars('ab'), 0).value,
        ).toBe('b')
    })

    it('expect (filter) to be accepted', () => {
        expect(
            C.char('a')
                .filter(function (a) {
                    return a === 'a'
                })
                .parse(stream.ofChars('a'), 0)
                .isAccepted(),
        ).toBe(true)
    })

    it('expect (filter) to be rejected', () => {
        expect(
            C.char('a')
                .filter(function (a) {
                    return a === 'b'
                })
                .parse(stream.ofChars('a'), 0)
                .isAccepted(),
        ).toBe(false)
    })

    it('expect (match) to be accepted', () => {
        expect(
            C.char('a').match('a').parse(stream.ofChars('a'), 0).isAccepted(),
        ).toBe(true)
    })

    it('expect (match) to be rejected', () => {
        expect(
            C.char('a').match('b').parse(stream.ofChars('a'), 0).isAccepted(),
        ).toBe(false)
    })

    it('expect (then) to be accepted', () => {
        expect(
            C.char('a')
                .then(C.char('b'))
                .parse(stream.ofChars('ab'), 0)
                .isAccepted(),
        ).toBe(true)
    })

    it('expect (then) left to be rejected', () => {
        expect(
            C.char('a')
                .then(C.char('b'))
                .parse(stream.ofChars('cb'), 0)
                .isAccepted(),
        ).toBe(false)
    })

    it('expect (then) right to be rejected', () => {
        expect(
            C.char('a')
                .then(C.char('b'))
                .parse(stream.ofChars('ac'), 0)
                .isAccepted(),
        ).toBe(false)
    })

    it('expect (then) to return [a,b]', () => {
        expect(
            C.char('a').then(C.char('b')).array().parse(stream.ofChars('ab'), 0)
                .value,
        ).toEqual(['a', 'b'])
    })

    it('expect (then) to return [a,b,d]', () => {
        expect(
            C.char('a')
                .then(C.char('b').then(C.char('c').drop()).then(C.char('d')))
                .array()
                .parse(stream.ofChars('abcd'), 0).value,
        ).toEqual(['a', 'b', 'd'])
    })

    it('expect (then) to be empty with two drops', () => {
        const parser = C.char('a').drop().then(C.char('b').drop())

        const value = parser.parse(stream.ofChars('ab')).value.value

        expect(Array.isArray(value)).toBe(true)
        expect(value.length).toBe(0)
    })

    it('expect (then) to be associative', () => {
        const first = C.char('a')
            .then(C.char('b'))
            .then(C.char('c').drop())
            .then(C.char('d'))
            .array()

        const second = C.char('a')
            .then(C.char('b'))
            .then(C.char('c').drop().then(C.char('d')))
            .array()

        expect(first.parse(stream.ofChars('abcd')).value).toEqual(
            second.parse(stream.ofChars('abcd')).value,
        )
    })

    it('expect (then) to be replaced by concat', () => {
        expect(
            C.char('a')
                .concat(C.char('b'))
                .then(C.char('c').drop())
                .concat(C.char('d'))
                .array()
                .parse(stream.ofChars('abcd'), 0).value,
        ).toEqual(['a', 'b', 'd'])
    })

    it('expect (thenLeft) to be accepted', () => {
        expect(
            C.char('a')
                .thenLeft(C.char('b'))
                .parse(stream.ofChars('ab'), 0)
                .isAccepted(),
        ).toBe(true)
    })

    it('expect (thenLeft) to return a', () => {
        expect(
            C.char('a')
                .thenLeft(C.char('b'))
                .single()
                .parse(stream.ofChars('ab'), 0).value,
        ).toBe('a')
    })

    it('expect (thenLeft) to be rejected', () => {
        expect(
            C.char('a')
                .thenLeft(C.char('b'))
                .parse(stream.ofChars('b'), 0)
                .isAccepted(),
        ).toBe(false)
    })

    it('expect (thenRight) to be accepted', () => {
        expect(
            C.char('a')
                .thenRight(C.char('b'))
                .parse(stream.ofChars('ab'), 0)
                .isAccepted(),
        ).toBe(true)
    })

    it('expect (thenRight) to return a', () => {
        expect(
            C.char('a')
                .thenRight(C.char('b'))
                .single()
                .parse(stream.ofChars('ab'), 0).value,
        ).toBe('b')
    })

    it('expect (thenRight) to be rejected', () => {
        expect(
            C.char('a')
                .thenRight(C.char('b'))
                .parse(stream.ofChars('b'), 0)
                .isAccepted(),
        ).toBe(false)
    })

    it('expect (drop/then) to be accepted', () => {
        expect(
            C.char('a')
                .drop()
                .then(C.char('b'))
                .parse(stream.ofChars('ab'), 0)
                .isAccepted(),
        ).toBe(true)
    })

    it('expect (drop/then) to be return b', () => {
        expect(
            C.char('a')
                .drop()
                .then(C.char('b'))
                .single()
                .parse(stream.ofChars('ab'), 0).value,
        ).toBe('b')
    })

    it('expect (then/drop) to be accepted', () => {
        expect(
            C.char('a')
                .then(C.char('b').drop())
                .parse(stream.ofChars('ab'), 0)
                .isAccepted(),
        ).toBe(true)
    })

    it('expect (drop/then) to be return a', () => {
        expect(
            C.char('a')
                .then(C.char('b').drop())
                .single()
                .parse(stream.ofChars('ab'), 0).value,
        ).toBe('a')
    })

    it('expect (eos) to be accepted at the end', () => {
        const parser = C.string('abc').eos()
        const response = parser.parse(stream.ofChars('abc'))

        expect(response.isAccepted()).toBe(true)
        expect(response.isEos()).toBe(true)
        expect(response.value).toBe('abc')
    })

    it('expect (eos) to be rejected without eating char', () => {
        const parser = C.char('a').eos()
        const response = parser.parse(stream.ofChars('ab'))

        expect(response.isAccepted()).toBe(false)
        expect(response.isEos()).toBe(false)
        expect(response.offset).toBe(1)
        expect(response.value).toBeUndefined()
    })

    it('expect rejected (eos) to be rejected keeping previous offset', () => {
        const parser = C.char('a').then(C.char('a')).eos()
        const response = parser.parse(stream.ofChars('ab is ending at 1'))

        expect(response.isAccepted()).toBe(false)
        expect(response.isEos()).toBe(false)
        expect(response.offset).toBe(1)
        expect(response.value).toBeUndefined()
    })

    it('expect (thenEos) to be accepted at the end', () => {
        expect(
            C.char('a').thenEos().parse(stream.ofChars('a')).isAccepted(),
        ).toBe(true)
    })

    it('expect (thenEos) to be rejected if not the end', () => {
        expect(
            C.char('a').thenEos().parse(stream.ofChars('abc')).isAccepted(),
        ).toBe(false)
    })

    it('expect (returns) to be accepted', () => {
        expect(
            C.char('a')
                .returns('b')
                .parse(stream.ofChars('ab'), 0)
                .isAccepted(),
        ).toBe(true)
    })

    it('expect (returns) to return b', () => {
        expect(
            C.char('a').returns('b').parse(stream.ofChars('ab'), 0).value,
        ).toBe('b')
    })

    it('expect (returns) not to eat char', () => {
        expect(
            C.char('a')
                .returns('X')
                .then(C.char('b'))
                .array()
                .parse(stream.ofChars('ab'), 0).value,
        ).toEqual(['X', 'b'])
    })

    it('expect (returns) to be rejected', () => {
        expect(
            C.char('a').returns('b').parse(stream.ofChars('b'), 0).isAccepted(),
        ).toBe(false)
    })

    it('expect (or) to be accepted', () => {
        expect(
            C.char('a')
                .or(C.char('b'))
                .parse(stream.ofChars('a'), 0)
                .isAccepted(),
        ).toBe(true)
    })

    it('expect (or) to be rejected', () => {
        expect(
            C.char('a')
                .or(C.char('b'))
                .parse(stream.ofChars('c'), 0)
                .isAccepted(),
        ).toBe(false)
    })

    it('expect (or) LL(1) to be rejected', () => {
        expect(
            C.char('a')
                .then(C.char('b'))
                .or(C.char('a'))
                .parse(stream.ofChars('ac'), 0)
                .isAccepted(),
        ).toBe(false)
    })

    it('expect (or) to return a', () => {
        expect(
            C.char('a').or(C.char('b')).parse(stream.ofChars('a'), 0).value,
        ).toBe('a')
    })

    it('expect (or) to return b', () => {
        expect(
            C.char('a').or(C.char('b')).parse(stream.ofChars('b'), 0).value,
        ).toBe('b')
    })

    it('expect (then.or) left to be rejected', () => {
        expect(
            C.char('a')
                .then(C.char('b').or(C.char('c')))
                .parse(stream.ofChars('ad'), 0)
                .isAccepted(),
        ).toBe(false)
    })

    it('expect (then.or) left to be consumed', () => {
        expect(
            C.char('a')
                .then(C.char('b').or(C.char('c')))
                .parse(stream.ofChars('ad'), 0).consumed,
        ).toBe(true)
    })

    it('expect (opt) some to accepted', () => {
        expect(
            C.char('a').opt().parse(stream.ofChars('a'), 0).isAccepted(),
        ).toBe(true)
    })

    it('expect (opt) some to return some a', () => {
        expect(
            C.char('a').opt().parse(stream.ofChars('a'), 0).value.get(),
        ).toBe('a')
    })

    it('expect (opt) none to accepted', () => {
        expect(
            C.char('a').opt().parse(stream.ofChars('b'), 0).isAccepted(),
        ).toBe(true)
    })

    it('expect (opt) none to return none', () => {
        expect(
            C.char('a').opt().parse(stream.ofChars('b'), 0).value.isPresent(),
        ).toBe(false)
    })

    it('expect (rep) to accepted', () => {
        expect(
            C.char('a').rep().parse(stream.ofChars('a'), 0).isAccepted(),
        ).toBe(true)
    })

    it('expect (rep) to rejected', () => {
        expect(
            C.char('a').rep().parse(stream.ofChars('b'), 0).isAccepted(),
        ).toBe(false)
    })

    it('expect (rep) mutiple to accepted', () => {
        expect(
            C.char('a').rep().parse(stream.ofChars('aaaabbb'), 0).isAccepted(),
        ).toBe(true)
    })

    it('expect (rep) mutiple to return [a,a,a,a]', () => {
        expect(
            C.char('a').rep().parse(stream.ofChars('aaaabbb'), 0).value.array(),
        ).toEqual(['a', 'a', 'a', 'a'])
    })

    it('expect (optrep) to accepted', () => {
        expect(
            C.char('a').optrep().parse(stream.ofChars('a'), 0).isAccepted(),
        ).toBe(true)
    })

    it('expect (optrep) none to accepted', () => {
        expect(
            C.char('a').optrep().parse(stream.ofChars('b'), 0).isAccepted(),
        ).toBe(true)
    })

    it('expect (optrep) mutiple to accepted', () => {
        expect(
            C.char('a')
                .optrep()
                .parse(stream.ofChars('aaaabbb'), 0)
                .isAccepted(),
        ).toBe(true)
    })

    it('expect (optrep) mutiple to return some [a,a,a,a]', () => {
        expect(
            C.char('a')
                .optrep()
                .parse(stream.ofChars('aaaabbb'), 0)
                .value.array(),
        ).toEqual(['a', 'a', 'a', 'a'])
    })

    it('expect (optrep) to return none', () => {
        expect(
            C.char('a').optrep().parse(stream.ofChars('bbb'), 0).value.array(),
        ).toEqual([])
    })

    it('expect (optrep) to return [b,b,b]', () => {
        expect(
            C.notChar('a')
                .optrep()
                .parse(stream.ofChars('bbba'), 0)
                .value.array(),
        ).toEqual(['b', 'b', 'b'])
    })

    it('expect two (optrep) to be merged as [b,b,b,a]', () => {
        expect(
            C.char('b')
                .optrep()
                .then(C.char('a').optrep())
                .array()
                .parse(stream.ofChars('bbba'), 0).value,
        ).toEqual(['b', 'b', 'b', 'a'])
    })

    it('expect two (optrep) to return [[b,b,b],[a]] using array()', () => {
        expect(
            C.char('b')
                .optrep()
                .array()
                .then(C.char('a').optrep().array())
                .array()
                .parse(stream.ofChars('bbba'), 0).value,
        ).toEqual([['b', 'b', 'b'], ['a']])
    })

    it('expect debug() to make side effect', () => {
        const original = console.log
        let sideEffect = false

        console.log = function () {
            sideEffect = true
        }

        C.char('a').debug('found').optrep().parse(stream.ofChars('aaa'), 0)

        console.log = original
        expect(sideEffect).toBe(true)
    })

    it('expect debug(param, false) to make side effect', () => {
        const original = console.log
        let sideEffect = false

        console.log = function () {
            sideEffect = true
        }

        C.char('a')
            .debug('found', false)
            .optrep()
            .parse(stream.ofChars('aaa'), 0)

        console.log = original
        expect(sideEffect).toBe(true)
    })

    it('expect (debug) to not make side effect', () => {
        const original = console.log
        let sideEffect = false

        console.log = function () {
            sideEffect = true
        }

        C.char('a').debug('found').optrep().parse(stream.ofChars('xxxx'), 0)

        console.log = original
        expect(sideEffect).toBe(false)
    })

    it('joins a TupleParser resulting in a string', () => {
        const st = stream.ofChars('5x8')
        let combinator = F.any().rep().join('')
        expect(combinator.parse(st).value).toBe('5x8')

        combinator = F.any().rep().join('-')
        expect(combinator.parse(st).value).toBe('5-x-8')
    })

    it('fails with join() if it is not a TupleParser', () => {
        const st = stream.ofChars('5x8')
        let combinator = F.any().rep().first().join('')
        expect(() => combinator.parse(st)).toThrow()
    })
})



================================================
FILE: ingest/test/parsec/parser_extensions_test.spec.js
================================================
import { describe, it, expect } from 'vitest'
import stream from '../../lib/stream/index'
import { F, C, N } from '../../lib/core/index'

describe('Parser Extensions Tests', () => {
    it('expect (returns) to be accepted', () => {
        expect(F.returns().parse(stream.ofChars(''), 0).isAccepted()).toBe(true)
    })

    it('expect (returns) to return a given value', () => {
        expect(F.returns(123).parse(stream.ofChars(''), 0).value).toBe(123)
    })

    it('expect (returns) to be rejected', () => {
        expect(F.error().parse(stream.ofChars(''), 0).isAccepted()).toBe(false)
    })

    it('expect (lazy) to be accepted', () => {
        expect(
            F.lazy(function () {
                return F.returns()
            })
                .parse(stream.ofChars(''), 0)
                .isAccepted(),
        ).toBe(true)
    })

    it('expect (lazy) to return a given value', () => {
        expect(
            F.lazy(function () {
                return F.returns(123)
            }).parse(stream.ofChars(''), 0).value,
        ).toBe(123)
    })

    it('expect (lazy with empty params) to return a given value', () => {
        expect(
            F.lazy(function () {
                return F.returns(123)
            }, []).parse(stream.ofChars(''), 0).value,
        ).toBe(123)
    })

    it('expect (lazy) to be rejected', () => {
        expect(
            F.lazy(function () {
                return F.error()
            })
                .parse(stream.ofChars(''), 0)
                .isAccepted(),
        ).toBe(false)
    })

    it('expect (lazy) with a parameter to return a given value', () => {
        expect(
            F.lazy(
                function (v) {
                    return F.returns(v)
                },
                [123],
            ).parse(stream.ofChars(''), 0).value,
        ).toBe(123)
    })

    it('expect (lazy) with multiple parameters to return a given value', () => {
        expect(
            F.lazy(
                function (v1, v2) {
                    return F.returns(v1 + v2)
                },
                [10, 20],
            ).parse(stream.ofChars(''), 0).value,
        ).toBe(30)
    })

    it('expect (lazy) with unpacked parameters to fail', () => {
        let found = false
        try {
            const combinator = F.lazy((v1, v2) => F.returns(v1 + v2), 10, 20)
            combinator.parse(stream.ofChars(''), 0)
        } catch (e) {
            if (e.includes('packed into an array')) {
                found = true
            }
        }
        expect(found).toBe(true)
    })

    it('expect (error) to be rejected', () => {
        expect(F.error().parse(stream.ofChars(''), 0).isAccepted()).toBe(false)
    })

    it('expect (eos) to be accepted', () => {
        expect(F.eos().parse(stream.ofChars(''), 0).isAccepted()).toBe(true)
    })

    it('expect (eos) to be rejected', () => {
        expect(F.eos().parse(stream.ofChars('a'), 0).isAccepted()).toBe(false)
    })

    it('expect (satisfy) to be accepted', () => {
        expect(
            F.satisfy(function (v) {
                return v === 'a'
            })
                .parse(stream.ofChars('a'), 0)
                .isAccepted(),
        ).toBe(true)
    })

    it('expect (satisfy) to be return the right value', () => {
        expect(
            F.satisfy(function (v) {
                return v === 'a'
            }).parse(stream.ofChars('a'), 0).value,
        ).toBe('a')
    })

    it('expect (satisfy) to be return the right offset', () => {
        expect(
            F.satisfy(function (v) {
                return v === 'a'
            }).parse(stream.ofChars('a'), 0).offset,
        ).toBe(1)
    })

    it('expect (satisfy) to be rejected', () => {
        expect(
            F.satisfy(function (v) {
                return v === 'b'
            })
                .parse(stream.ofChars('a'), 0)
                .isAccepted(),
        ).toBe(false)
    })

    it('expect (doTry satisfy) to be accepted', () => {
        expect(
            F.try(
                F.satisfy(function (v) {
                    return v === 'a'
                }),
            )
                .parse(stream.ofChars('a'), 0)
                .isAccepted(),
        ).toBe(true)
    })

    it('expect (doTry satisfy) to be rejected', () => {
        expect(
            F.try(
                F.satisfy(function (v) {
                    return v === 'b'
                }),
            )
                .parse(stream.ofChars('a'), 0)
                .isAccepted(),
        ).toBe(false)
    })

    it('expect (digit) to be accepted', () => {
        expect(N.digit().parse(stream.ofChars('1'), 0).isAccepted()).toBe(true)
    })

    it('expect (digit) to be rejected', () => {
        expect(N.digit().parse(stream.ofChars('a'), 0).isAccepted()).toBe(false)
    })

    it('expect (number) to be accepted', () => {
        expect(N.number().parse(stream.ofChars('123'), 0).isAccepted()).toBe(
            true,
        )
    })

    it('expect (number) to return 123', () => {
        expect(N.number().parse(stream.ofChars('123'), 0).value).toBe(123)
    })

    it('expect negative (number) to be accepted', () => {
        expect(N.number().parse(stream.ofChars('-123'), 0).isAccepted()).toBe(
            true,
        )
    })

    it('expect negative (number) to return -123', () => {
        expect(N.number().parse(stream.ofChars('-123'), 0).value).toBe(-123)
    })

    it('expect float (number) to be accepted', () => {
        expect(
            N.number().parse(stream.ofChars('123.34e-34'), 0).isAccepted(),
        ).toBe(true)
    })

    it('expect float (number) to return 123.34e-34', () => {
        expect(N.number().parse(stream.ofChars('123.34e-34'), 0).value).toBe(
            123.34e-34,
        )
    })

    it('expect (charLiteral) to be accepted', () => {
        expect(
            C.charLiteral().parse(stream.ofChars("'a'"), 0).isAccepted(),
        ).toBe(true)
    })

    it('expect (charLiteral) to return a', () => {
        expect(C.charLiteral().parse(stream.ofChars("'a'"), 0).value).toBe('a')
    })

    it('expect (charLiteral) quote to be accepted', () => {
        expect(
            C.charLiteral().parse(stream.ofChars("'\\''"), 0).isAccepted(),
        ).toBe(true)
    })

    it('expect (charLiteral) to be rejected', () => {
        expect(
            C.charLiteral().parse(stream.ofChars("''"), 0).isAccepted(),
        ).toBe(false)
    })

    it('expect (stringLiteral) to be accepted', () => {
        expect(
            C.stringLiteral().parse(stream.ofChars('"a"'), 0).isAccepted(),
        ).toBe(true)
    })
})



================================================
FILE: ingest/test/parsec/parser_stream_test.spec.js
================================================
import { describe, it, expect } from 'vitest'
import stream from '../../lib/stream/index'
import C from '../../lib/core/chars-bundle'
import N from '../../lib/core/numbers-bundle'
import Stream from '../../lib/stream'
import unit from '../../lib/data/unit'

function spaces() {
    return C.charIn(' \r\n\f\t')
        .optrep()
        .map(() => unit)
}

describe('Parser Stream Tests', () => {
    it('endOfStream for empty stream', () => {
        const p = C.char(' ').optrep().thenRight(N.number())
        expect(stream.ofParsers(p, stream.ofChars('')).endOfStream(0)).toBe(
            true,
        )
    })

    it('endOfStream for non empty stream', () => {
        const p = C.char(' ').optrep().thenRight(N.number())
        expect(stream.ofParsers(p, stream.ofChars('1')).endOfStream(1)).toBe(
            true,
        )
    })

    it('no endOfStream for non empty stream', () => {
        const p = C.char(' ').optrep().thenRight(N.number())
        expect(stream.ofParsers(p, stream.ofChars('1')).endOfStream(0)).toBe(
            false,
        )
    })

    it('get from stream', () => {
        const p = C.char(' ').optrep().thenRight(N.number())
        expect(
            stream.ofParsers(p, stream.ofChars('1')).get(0).isSuccess(),
        ).toBe(true)
    })

    it('do not get from empty stream', () => {
        const p = C.char(' ').optrep().thenRight(N.number())
        expect(
            stream.ofParsers(p, stream.ofChars('1')).get(1).isSuccess(),
        ).toBe(false)
    })

    it('get from stream number 123', () => {
        const p = C.char(' ').optrep().thenRight(N.number()).single()
        expect(
            stream.ofParsers(p, stream.ofChars('123')).get(0).success(),
        ).toBe(123)
    })

    it('Offset are found in series of numbers', () => {
        const p = N.number().then(C.char(' ').optrep().drop()).single()

        const parserStream = stream.ofParsers(p, stream.ofChars('123   14137'))
        // index: ^0    ^6

        const first = parserStream.get(0).success() //>> 123
        expect(first).toBe(123)

        const second = parserStream.get(1).success() //>> 114
        expect(second).toBe(14137)
        expect(parserStream.offsets).toEqual([0, 6, 11])
    })

    it('failing series of numbers', () => {
        const p = N.number().then(C.char(' ').optrep().drop()).single()
        const parserStream = stream.ofParsers(p, stream.ofChars('123   a'))
        //                                                index: ^0    ^6

        const first = parserStream.get(0).success() //>> 123
        expect(first).toBe(123)
        expect(parserStream.offsets).toEqual([0, 6])

        const second = parserStream.get(1) // try 'a'
        expect(second.isFailure()).toBe(true)

        expect(parserStream.offsets).toEqual([0, 6])
    })

    it('having correct location when success', () => {
        const p = N.number().then(C.char(' ').optrep().drop()).single()

        const parserStream = stream.ofParsers(p, stream.ofChars('123   14137'))
        //                                                index: ^0    ^6

        const first = parserStream.get(0).success() //>> 123
        expect(first).toBe(123)
        expect(parserStream.location(0)).toBe(0)

        const second = parserStream.get(1).success() //>> 114
        expect(second).toBe(14137)
        expect(parserStream.location(1)).toBe(6)
    })

    it('searching illegal location will fail', () => {
        const p = N.number().then(C.char(' ').optrep().drop()).single()

        const parserStream = stream.ofParsers(p, stream.ofChars('123   14137'))
        //                                                index: ^0    ^6

        const first = parserStream.get(0).success() //>> 123
        expect(first).toBe(123)

        expect(() => parserStream.location(4)).toThrow()
    })

    it('having correct location when fail', () => {
        const p = N.number()

        const parserStream = stream.ofParsers(p, stream.ofChars('1234   14137'))
        //                                                index: ^0  ^4

        const first = parserStream.get(0).success() //>> 123
        expect(first).toBe(1234)
        expect(parserStream.location(0)).toBe(0)

        parserStream.get(1) //>> fail
        expect(parserStream.location(1)).toBe(4)
    })

    it('unsafe_get can see next element', () => {
        const lower = N.number().then(spaces().opt().drop()).single()

        const lowerStream = Stream.ofChars('10 12 44')
        const parserStream = Stream.ofParsers(lower, lowerStream)

        parserStream.unsafeGet(0)
        const value = parserStream.unsafeGet(1)

        expect(value).toBe(12)
    })

    it('unsafe_get cannot see beyond next element', () => {
        const lower = N.number().then(spaces().opt().drop())

        const lowerStream = Stream.ofChars('10 12 44')
        const parserStream = Stream.ofParsers(lower, lowerStream)

        expect(() => parserStream.unsafeGet(1)).toThrow()
    })
})



================================================
FILE: ingest/test/parsec/response_test.spec.js
================================================
import { describe, it, expect } from 'vitest'
import response from '../../lib/core/response'
import stream from '../../lib/stream/index'

describe('Response Tests', () => {
    it('response accepted', () => {
        expect(response.accept().isAccepted()).toBe(true)
    })

    it('response as a success', () => {
        expect(response.accept().toTry().isSuccess()).toBe(true)
    })

    it('response accepted map to accepted', () => {
        expect(
            response
                .accept()
                .map(function (a) {
                    return a
                })
                .isAccepted(),
        ).toBe(true)
    })

    it('response accepted map to return the value', () => {
        expect(
            response.accept('a').map(function (a) {
                return a
            }).value,
        ).toBe('a')
    })

    it('response accepted map to pass in response as second argument', () => {
        expect(
            response.accept('a').map(function (_, response) {
                return response
            }).value,
        ).toEqual(response.accept('a'))
    })

    it('response accepted flatMap to accepted', () => {
        expect(
            response
                .accept('a')
                .flatMap(function (a) {
                    return response.accept(a)
                })
                .isAccepted(),
        ).toBe(true)
    })

    it('response accepted flatMap knows the offset', () => {
        const responseOffset = response
            .accept('a', 'abc', 1, false)
            .flatMap(function (a, response) {
                return response.offset
            })

        expect(responseOffset).toBe(1)
    })

    it('response accepted flatMap to return the value', () => {
        expect(
            response
                .accept('a')
                .flatMap(function (a) {
                    return response.accept(a)
                })
                .isAccepted(),
        ).toBe(true)
    })

    it('response accepted flatMap to reject', () => {
        expect(
            response
                .accept()
                .flatMap(function () {
                    return response.reject()
                })
                .isAccepted(),
        ).toBe(false)
    })

    it('response rejected map to rejected', () => {
        expect(
            response
                .reject()
                .map(function (t) {
                    return t
                })
                .isAccepted(),
        ).toBe(false)
    })

    it('response rejected map callback not called', () => {
        let calls = 0
        response.reject().map(function () {
            calls++
        })
        expect(calls).toBe(0)
    })

    it('response rejected flatMap to rejected', () => {
        expect(
            response
                .reject()
                .flatMap(function () {
                    return response.accept()
                })
                .isAccepted(),
        ).toBe(false)
    })

    it('response rejected flatMap callback not called', () => {
        let calls = 0
        response.reject().flatMap(function () {
            calls++
        })
        expect(calls).toBe(0)
    })

    it('response accepted fold', () => {
        expect(
            response.accept('a').fold(function (a) {
                return a.value
            }),
        ).toBe('a')
    })

    it('fold takes a function to map the value depending on result', () => {
        let value = response.accept('a').fold(
            (accept) => accept.value + '-potato', // Accept has value, input, offset, consumed
            (reject) => reject.offset + '-tomato',
        ) // Reject has offset, consumed

        // we accept, so it should be a-potato
        expect(value).toBe('a-potato')

        value = response.reject().fold(
            (accept) => accept.value + '-potato',
            (reject) => reject.offset + '-tomato',
        )

        // we reject, so it should use the second function
        // Offset is undefined because it's up to the parser to know which offset it's parsing
        expect(value).toBe('undefined-tomato')
    })

    it('response filter accepted', () => {
        expect(
            response
                .accept('a')
                .filter(function (a) {
                    return a === 'a'
                })
                .isAccepted(),
        ).toBe(true)
    })

    it('response not filter accepted', () => {
        expect(
            response
                .accept('a')
                .filter(function (a) {
                    return a !== 'a'
                })
                .isAccepted(),
        ).toBe(false)
    })

    it('accept can be consumed', () => {
        const myStream = stream.ofChars('abc')
        const acceptance = response.accept('c', myStream, 3, false)
        const consumed = acceptance.isEos()
        expect(consumed).toBe(true)
    })

    it('accept should not be yet consumed', () => {
        const myStream = stream.ofChars('abc')
        expect(response.accept('b', myStream, 2, false).isEos()).toBe(false)
    })

    it('response rejected', () => {
        expect(response.reject().isAccepted()).toBe(false)
    })

    it('response rejected should not be consumed', () => {
        expect(response.reject().isEos()).toBe(false)
    })

    it('response as a failure', () => {
        expect(response.reject().toTry().isSuccess()).toBe(false)
    })

    it('response rejected fold', () => {
        expect(
            response.reject().fold(
                function (a) {
                    return a.value
                },
                function () {
                    return 'b'
                },
            ),
        ).toBe('b')
    })

    it('response filter rejected', () => {
        expect(
            response
                .reject()
                .filter(function () {
                    return true
                })
                .isAccepted(),
        ).toBe(false)
    })

    it('response not filter rejected', () => {
        expect(
            response
                .reject()
                .filter(function () {
                    return false
                })
                .isAccepted(),
        ).toBe(false)
    })
})



================================================
FILE: ingest/test/parsec/tuple-parser-test.spec.js
================================================
import { describe, it, expect } from 'vitest'
import { Stream } from '../../lib/index.js'
import { F, C } from '../../lib/core/index'

describe('Tuple Parser Tests', () => {
    it('expect p.first() to work', () => {
        let text = 'abc'
        let parser = C.letter().rep().first()

        expect(parser.val(text)).toBe('a')
    })

    it('expect p.last() to work', () => {
        let text = 'abc'
        let parser = C.letter().rep().last()

        expect(parser.val(text)).toBe('c')
    })

    it('expect p.at() to work', () => {
        let text = 'abc'
        let parser = C.letter()
            .rep()
            .map((t) => t.at(2))

        expect(parser.val(text)).toBe('c')
    })

    it('expect p.array to fail if not a tupleParser', () => {
        let text = 'abc'
        let parser = C.letters().array()

        expect(() => parser.val(text)).toThrow()
    })

    it('expect F.nop to be like a empty tuple', () => {
        let text = 'ab'
        const stream = Stream.ofChars(text)
        let parser = C.char('a').then(F.nop()).then(C.char('b')).join()
        let parsing = parser.parse(stream)
        expect(parsing.isAccepted()).toBe(true)
        expect(parsing.value).toEqual('ab')

        parser = F.nop()
            .then(C.char('a'))
            .then(F.nop())
            .then(C.char('b'))
            .then(F.nop())
            .join()
        parsing = parser.parse(stream)
        expect(parsing.isAccepted()).toBe(true)
        expect(parsing.value).toEqual('ab')
    })
})



================================================
FILE: ingest/test/specific/f-empty-try.spec.js
================================================
import { describe, it, expect } from 'vitest'
import Stream from '../../lib/stream/index'
import { F, C } from '../../lib/core/index'

describe('Failed Try', () => {
    it('separate the problem of F.try only', () => {
        function emptyTry() {
            return F.try(C.string('a'))
        }

        const inputString = 'b' // Simplified input for clarity
        let stream = Stream.ofChars(inputString)
        let parsing = emptyTry().parse(stream)

        expect(parsing.isAccepted()).toBe(false) // Should be accepted
        expect(parsing.offset).toBe(0) // Should be at the start of the string
        expect(parsing.value).toEqual(undefined) // Should not have a value

        /**
         * RESOLUTION: It works accordingly: after a failed try, the parsing is NOT
         * accepted. However, the offset is not moved, and the value is undefined,
         * which give us the opportunity to use `F.try(x).or(anotherParser)`.
         */
    })
})



================================================
FILE: ingest/test/stream/array-stream-test.spec.js
================================================
import { describe, it, expect } from 'vitest'
import Stream from '../../lib/stream/index'

describe('Array Stream Tests', () => {
    it('We can get a response from array', () => {
        const document = ['More', 'XYZ']
        const line = Stream.ofArrays(document)

        let response = line.get(0)
        expect(response.value).toBe('More')
    })

    it('We have reached out of stream', () => {
        const document = ['More', 'XYZ']
        const line = Stream.ofArrays(document)

        let out = line.endOfStream(3)
        expect(out).toBe(true)

        out = line.endOfStream(1)
        expect(out).toBe(false)
    })
})



================================================
FILE: ingest/test/stream/buffered_stream_test.spec.js
================================================
import { describe, it, expect } from 'vitest'
import stream from '../../lib/stream/index'

describe('Buffered Stream Tests', () => {
    it('endOfStream for empty stream', () => {
        expect(stream.buffered(stream.ofChars('')).endOfStream(0)).toBe(true)
    })

    it('endOfStream for non empty stream', () => {
        expect(stream.buffered(stream.ofChars('1')).endOfStream(1)).toBe(true)
    })

    it('no endOfStream for non empty stream', () => {
        expect(stream.buffered(stream.ofChars('1')).endOfStream(0)).toBe(false)
    })

    it('get from stream', () => {
        expect(stream.buffered(stream.ofChars('1')).get(0).isSuccess()).toBe(
            true,
        )
    })

    it('do not get from empty stream', () => {
        expect(stream.buffered(stream.ofChars('1')).get(1).isSuccess()).toBe(
            false,
        )
    })

    it('get from stream number 1', () => {
        expect(stream.buffered(stream.ofChars('123')).get(0).success()).toBe(
            '1',
        )
    })

    it('get from stream number is cached', () => {
        const s = stream.buffered(stream.ofChars('123'))
        const v = s.get(0)

        expect(s.get(0)).toBe(v)
    })
})



================================================
FILE: ingest/test/stream/offset-test.spec.js
================================================
import { describe, it, expect } from 'vitest'
import Stream from '../../lib/stream/index'
import { F, C } from '../../lib/core'

describe('Stream Offset Tests', () => {
    it('response ok with a CharStream', () => {
        const stream = Stream.ofChars('The world is a vampire')

        const parser = C.string('The')
        const response = parser.parse(stream, 0)

        expect(response.isAccepted()).toBe(true)
        expect(response.isEos()).toBe(false)
        expect(response.offset).toBe(3)
    })

    it('response ok inside a CharStream', () => {
        const stream = Stream.ofChars('The world is a vampire')

        const parser = C.string('world')
        const response = parser.parse(stream, 4)

        expect(response.isAccepted()).toBe(true)
        expect(response.isEos()).toBe(false)
        expect(response.offset).toBe(9)
    })

    it('response ok completing a CharStream', () => {
        const stream = Stream.ofChars('The world is a vampire')

        const parser = C.letter().or(C.char(' ')).rep()
        const response = parser.parse(stream)

        expect(response.isAccepted()).toBe(true)
        expect(response.isEos()).toBe(true)
        expect(response.offset).toBe(22)
    })

    it('response fails at CharStream start', () => {
        const stream = Stream.ofChars('The world is a vampire')

        const parser = C.string('That')
        const response = parser.parse(stream)

        expect(response.isAccepted()).toBe(false)
        expect(response.offset).toBe(0)
    })

    it('response fails inside a CharStream', () => {
        const stream = Stream.ofChars('abc de')

        const parser = C.string('abc').then(C.string('fails'))
        const response = parser.parse(stream)

        expect(response.isAccepted()).toBe(false)
        expect(response.offset).toBe(3)
    })

    it('response passes the CharStream', () => {
        const stream = Stream.ofChars('abc de')

        const parser = C.letter().or(C.char(' ')).rep().then(C.string('!!!'))
        const response = parser.parse(stream)

        expect(response.isAccepted()).toBe(false)

        // because an error has NEVER stream consumed
        expect(response.isEos()).toBe(false)
        expect(response.offset).toBe(stream.source.length)
    })

    it('response with a failed try is rejected, and offset is 0', () => {
        const stream = Stream.ofChars('abc de')

        const parser = F.try(C.string('abc').then(C.char('x'))).or(
            C.string('x'),
        )
        const response = parser.parse(stream)

        expect(response.isAccepted()).toBe(false)
        expect(response.offset).toBe(0)
    })
})



================================================
FILE: ingest/test/stream/stream_test.spec.js
================================================
import { describe, it, expect } from 'vitest'
import stream from '../../lib/stream/index'

describe('Stream Tests', () => {
    it('endOfStream for empty stream', () => {
        expect(stream.ofChars('').endOfStream(0)).toBe(true)
    })

    it('endOfStream for non empty stream', () => {
        expect(stream.ofChars('1').endOfStream(1)).toBe(true)
    })

    it('no endOfStream for non empty stream', () => {
        expect(stream.ofChars('1').endOfStream(0)).toBe(false)
    })

    it('get from stream', () => {
        expect(stream.ofChars('1').get(0).isSuccess()).toBe(true)
    })

    it('do not get from empty stream', () => {
        expect(stream.ofChars('1').get(1).isSuccess()).toBe(false)
    })

    it('do not get from erroneous stream', () => {
        expect(
            stream
                .ofChars({
                    length: 1,
                    charAt: function () {
                        throw new Error()
                    },
                })
                .get(0)
                .isSuccess(),
        ).toBe(false)
    })
})


